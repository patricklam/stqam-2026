\begin{enumerate}[label=(\alph*)]
\item (2 points) Give an example of a class of inputs for which grammar-based reduction works well, but which is not a
programming/expression language (e.g. arithmetic expressions, Python, Rust, Java, etc.) Let's say: something that is not
Turing-complete and not something that appears as a subset of some other language.

\item (4 points)
Here is a grammar-based reduction (using the depth concept) of \texttt{1 + (2 / (3 - 3)) * (5 + 7)}:
\begin{verbatim}
Test #1 '(2 / (3 - 3)) * (5 + 7)' 23 FAIL
Test #2 '(5 + 7)' 7 FAIL
Test #3 '(7)' 3 FAIL
Test #4 '7' 1 PASS
(7)
\end{verbatim}
Explain which reductions have taken place to obtain each of the tests, including the type of reduction, the node
being reduced, and what it is replaced by.

%slide 47: why is there no 3*2

\item (14 points) (From the \emph{Fuzzing Book}):

Grammar-based input reduction, as sketched above, might be a good algorithm, but is by no means the only alternative. One interesting question is whether ``reduction'' should only be limited to elements already present, or whether one would be allowed to also create new elements. These would not be present in the original input, yet still allow producing a much smaller input that would still reproduce the original failure.

As an example, consider the following grammar:

\begin{verbatim}
<number> ::= <float> | <integer> | <not-a-number>
<float> ::= <digits>.<digits>
<integer> ::= <digits>
<not-a-number> ::= NaN
<digits> ::= [0-9]+
\end{verbatim}

Assume the input 100.99 fails. We might be able to reduce it to a minimum of, say, 1.9. However, we cannot reduce it to an \brac{integer} or to \brac{not-a-number}, as these symbols do not occur in the original input. By allowing to create alternatives for these symbols, we could also test inputs such as \texttt{1} or \texttt{NaN} and further generalize the class of inputs for which the program fails.

In file \texttt{reducer.py} in the \texttt{a2-reducing-inputs} subdirectory of your \texttt{a2} repo, you'll find \texttt{GenerativeGrammarReducer}, a subclass of \texttt{GrammarReducer}. Implement overridden method \texttt{symbol\_reductions()} which uses the \texttt{GrammarFuzzer} (already imported) to generate new subtrees as one more option that \texttt{symbol\_reductions()} can create.

I've also provided a driver \texttt{generative\_grammar\_example.py} in the same directory. It sets a deterministic seed. You can run \texttt{python3 generative\_grammar\_example.py} to test your implementation.
\begin{verbatim}
~/c/s/a/a/a2-reducing-inputs> python3 generative_grammar_example.py
Test #1 '9.36' 4 PASS
Test #2 '5.8' 3 PASS
Test #3 '84.99' 5 PASS
Test #4 '100.9' 5 PASS
Test #5 '7.99' 4 PASS
Test #6 '100.8' 5 PASS
Test #7 'NaN' 3 FAIL
NaN
\end{verbatim}

\emph{Marking note:} I don't know how many different implementations we'll see, but any implementation that satisfies the specification here gets full marks. We will first try to mark your implementation by setting the seed to a value for marking and running your implementation; if it matches ours on that seed, then you get full marks. Otherwise we'll have to hand mark.
\end{enumerate}
