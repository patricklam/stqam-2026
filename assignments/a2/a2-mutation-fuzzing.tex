% use fuzzing on htmlparser starting from a string that is actual html

\begin{enumerate}[label=(\alph*)]
\item (2 points)
Python's \texttt{decimal} module supports ``decimal fixed-point and floating-point arithmetic''.
Write a \texttt{decimal\_fuzzer()} function in \texttt{a2-mutation-fuzzing/decimal\_fuzzer.py}
that creates a \texttt{decimal.Decimal} as follows:
it draws between 1 and 5 decimal digits to form an integral part, then between 0 and 3 decimal digits
to form a fractional part, and a random sign (+ or -). The skeleton also includes class \texttt{RandomFuzzer}
in \texttt{fuzzer.py}, and \texttt{decimal\_fuzzer.py} includes a \texttt{\_\_main\_\_} that invokes it.

\item (4 points) In this question we'll work on the \texttt{MutationCoverageFuzzer} and the \texttt{crashme} example from Lecture 8. Work through enough calls to \texttt{MutationCoverageFuzzer.run()}, to reach the \texttt{Exception}. You must show at least 3 calls to \texttt{run()}. Start with the seed \texttt{["good"]}. As you are working through the algorithm, you can choose any mutated input you want, but it has to be something that could be generated by the \texttt{MutationCoverageFuzzer} (explain how). Show the newly-generated input, along with the population and the coverage at each step. You can show the coverage as a set of line numbers from the above listing. Submit this answer to Crowdmark.

\item (14 points) (From the \emph{Fuzzing Book}:) When adding a new element to the list of candidates, AFL actually does not compare the coverage, but instead adds an element if it exercises a new branch.

In the \texttt{a2-mutation-fuzzing} directory you'll find \texttt{mutation\_coverage\_fuzzer\_branches.py} as well as the original \texttt{mutation\_coverage\_fuzzer.py}. You can call either of these from the Python command line. Using branch coverage from the exercises of the ``Coverage'' chapter, implement this ``branch'' strategy in the \texttt{run()} method of \texttt{mutation\_coverage\_fuzzer\_branches.py}. You may also modify \texttt{function\_coverage\_runner.py} as needed. Can you notice any difference compared to the previous strategy?
\end{enumerate}
