\documentclass{beamer}

% TODO: print out https://www.fuzzingbook.org/code/Intro_Testing.py

\usetheme{Boadilla}

%\includeonlyframes{current}

\usepackage{times}
\usefonttheme{structurebold}
\usepackage{listings}

\usepackage{pgf}
\usepackage{tikz}
\usepackage{alltt}
\usepackage[normalem]{ulem}
\usetikzlibrary{arrows}
\usetikzlibrary{automata}
\usetikzlibrary{shapes}
\usepackage{amsmath,amssymb}
\usepackage{rotating}
\usepackage{ulem}
\usepackage{pythonhighlight}

\usetikzlibrary{arrows,automata,shapes}
\tikzstyle{block} = [rectangle, draw, fill=blue!20, 
    text width=5em, text centered, rounded corners, minimum height=2em]
\tikzstyle{bt} = [rectangle, draw, fill=blue!20, 
    text width=4em, text centered, rounded corners, minimum height=2em]

\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, 
do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]''
}

%\setbeamercovered{dynamic}
\setbeamertemplate{footline}[page number]{}
\setbeamertemplate{navigation symbols}{}
\usefonttheme{structurebold}

\title{Software Testing, Quality Assurance \& Maintenance---Lecture 11}
\author{Patrick Lam\\University of Waterloo}
\date{February 9, 2026}

\colorlet{redshaded}{red!25!bg}
\colorlet{shaded}{black!25!bg}
\colorlet{shadedshaded}{black!10!bg}
\colorlet{blackshaded}{black!40!bg}

\colorlet{darkred}{red!80!black}
\colorlet{darkblue}{blue!80!black}
\colorlet{darkgreen}{green!80!black}

\newcommand{\rot}[1]{\rotatebox{90}{\mbox{#1}}}
\newcommand{\gray}[1]{\mbox{#1}}

\newenvironment{changemargin}[1]{% 
  \begin{list}{}{% 
    \setlength{\topsep}{0pt}% 
    \setlength{\leftmargin}{#1}% 
    \setlength{\rightmargin}{1em}
    \setlength{\listparindent}{\parindent}% 
    \setlength{\itemindent}{\parindent}% 
    \setlength{\parsep}{\parskip}% 
  }% 
  \item[]}{\end{list}}

\newcommand{\brac}[1]{\texttt{\textless #1\textgreater}}


\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\usebackgroundtemplate{\tikz\node[opacity=0.3]{\includegraphics[width=\paperwidth]{L11/06400_big_and_small_sheep_v2.JPG}};}
\part{Reducing Inputs}
\begin{frame}
  \partpage
\end{frame}
\usebackgroundtemplate{}

\begin{frame}
  \frametitle{\LaTeX~errors}
  \includegraphics[width=\paperwidth]{L11/latex-error.png}
  \begin{changemargin}{2cm}
    \Large
    To ask for help on StackExchange, need a \alert{Minimal Working Example}.
  \end{changemargin}
\end{frame}

\usebackgroundtemplate{\includegraphics[width=\paperwidth]{L01/00856_destroyed_bridge_ribbon_falls.JPG}}
\begin{frame}

\end{frame}
\usebackgroundtemplate{}

\begin{frame}[fragile]
  \frametitle{Fixing a bug}
  \Large
  \begin{changemargin}{2cm}
    \begin{enumerate}
    \item need to reproduce the bug, so need a working example;
      \item better yet: a \emph{minimal} working example is easier to deal with.
    \end{enumerate}
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{MWEs and Fuzzing}
  \Large
  \begin{changemargin}{2cm}
    Fuzzers produce large inputs.\\[1em]
    When input contains extraneous context, \\
    \qquad hard to understand what's happening.
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Reducing an input}
  \Large
  \begin{changemargin}{1cm}
    We'll show a way to \alert{reduce} a failing input:\\[1em]
  \end{changemargin}
  \begin{changemargin}{2cm}
    ``to identify those
circumstances of a failure that are relevant for the failure to occur, and to \emph{omit} (if possible)
those parts that are not''
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{A Mystery}
  \Large
\begin{python}
class MysteryRunner(Runner):
    def run(self, inp: str) -> Tuple[str, Outcome]:
        x = inp.find(chr(0o17 + 0o31))
        y = inp.find(chr(0o27 + 0o22))
        if x >= 0 and y >= 0 and x < y:
            return (inp, Runner.FAIL)
        else:
            return (inp, Runner.PASS)
\end{python}
\begin{changemargin}{2cm}
  Fails on some inputs. Can use \texttt{RandomFuzzer} to find a failure.
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Fuzzing a Failure}
  \Large
\begin{python}
def fuzz_mystery_runner():
    mystery = MysteryRunner()
    random_fuzzer = RandomFuzzer()
    while True:
        inp = random_fuzzer.fuzz()
        result, outcome = mystery.run(inp)
        if outcome == mystery.FAIL:
            break
    print (result)
\end{python}

\begin{changemargin}{1cm}
This works and eventually finds a failing input.\\
(Manually, took me 6 tries.)

\begin{verbatim}
$ python3 mystery_runner.py
(%*50  1)-&7,;49:4?%:43*(-.
\end{verbatim}
  But why?
\end{changemargin}

\end{frame}

%\usebackgroundtemplate{\tikz\node[opacity=0.3]{\includegraphics[width=\paperwidth]{L11/06400_big_and_small_sheep_v2.JPG}};}
\part{Manual Input Reduction}
\begin{frame}
  \partpage
\end{frame}
%\usebackgroundtemplate{}

\begin{frame}[fragile]
  \frametitle{Divide and Conquer}
  \Large

\begin{changemargin}{1cm}
  Kernighan and Pike recommend:\\[1em]
\end{changemargin}
\begin{changemargin}{2cm}
  Proceed by binary search. Throw away half the input and see if the output is still wrong; if not, go back to the previous state and discard the other half of the input.
\end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Does this work?}
  \Large
\begin{python}
>>> from mystery_runner import *
>>> failing_input = "(%*50  1)-&7,;49:4?%:43*(-."
>>> mystery = MysteryRunner()
>>> mystery.run(failing_input)
('(%*50  1)-&7,;49:4?%:43*(-.', 'FAIL')
>>> half_length = len(failing_input) // 2 # integer division
>>> first_half = failing_input[:half_length]
>>> mystery.run(first_half)
('(%*50  1)-&7,', 'FAIL')
\end{python}
\begin{changemargin}{2cm}
  Progress! Halved the original input.
\end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Failing at Failing}
  \Large
\begin{python}
>>> quarter_length = len(first_half) // 2
>>> first_quarter = first_half[quarter_length:]
>>> mystery.run(first_quarter)
(' 1)-&7,', 'PASS')
>>> second_quarter = first_half[:quarter_length]
>>> mystery.run(second_quarter)
('(%*50 ', 'PASS')
\end{python}
\begin{changemargin}{1cm}
  Same trick doesn't work again. \\
  The code says it's looking for two characters, \\
  but in our test case, the characters aren't in the same quarter.
\end{changemargin}
\end{frame}

\usebackgroundtemplate{\tikz\node[opacity=0.3]{\includegraphics[width=\paperwidth]{L11/00219_falling_rocks.JPG}};}
\part{Delta Debugging}
\begin{frame}
  \partpage
\end{frame}
\usebackgroundtemplate{}

\begin{frame}[fragile]
  \frametitle{A Change in Perspective}
  \Large
  \begin{changemargin}{2cm}
    We tried direct binary search---didn't work.\\[1em]
    \alert{Delta debugging} is another way.\\[1em]
    We instead \emph{remove} smaller and smaller parts of the input,\\
    and see if it still fails.\\[1em]
    Intuitively: more likely to keep the brokenness.
\end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Example: Removing Quarters 1}
  \Large
  \begin{changemargin}{2cm}
    Let's start with the first quarter.
\begin{python}
>>> quarter_length=len(failing_input)//4
>>> input_without_first_quarter=failing_input[quarter_length:]
>>> mystery.run(input_without_first_quarter)
(' 1)-&7,;49:4?%:43*(-.', 'PASS')
\end{python}
PASS, so must keep 1st quarter.
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Example: Removing Quarters 2}
  \Large
  \begin{changemargin}{2cm}
    Now for the second quarter.
\begin{python}
>>> input_without_second_quarter=failing_input[:quarter_length]+failing_input[quarter_length*2:]
>>> mystery.run(input_without_second_quarter)
('(%*50 ,;49:4?%:43*(-.', 'PASS')
\end{python}

We knew this already: \\
\qquad \qquad must keep the first half.\\[1em]
We also know we can discard the second half, but let's see.
  \end{changemargin}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Example: Removing Quarters 3, 4}
  \Large
\begin{python}
>>> input_without_3rd_quarter=
     failing_input[:quarter_length*2]+failing_input[quarter_length*3:]
>>> mystery.run(input_without_3rd_quarter)
('(%*50  1)-&7?%:43*(-.', 'FAIL')
>>> input_without_4th_quarter=failing_input[:quarter_length*3]
>>> mystery.run(input_without_4th_quarter)
('(%*50  1)-&7,;49:4', 'FAIL')
\end{python}
\begin{changemargin}{2cm}
  This doesn't tell us anything new, \\
  but we're sort of following the algorithm.\\[1em]
  (The algorithm doesn't actually quite work like this.)
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Infrastructure for Reducing}
  \Large
  \begin{changemargin}{2cm}
    An abstract base class that doesn't really do anything.
  \end{changemargin}
\begin{python}
class Reducer:
    def __init__(self, runner: Runner, log_test: bool = False) -> None:
       # ...

    def test(self, inp: str) -> Outcome:
       # ...

    def reduce(self, inp: str) -> str:
       # here, non-real (abstract) impl
\end{python}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Caching}
  \Large
  \begin{changemargin}{2cm}
We can cache results:
  \end{changemargin}
\begin{python}
class CachingReducer(Reducer):
    def test(self, inp):
        if inp in self.cache:
            return self.cache[inp]

        outcome = super().test(inp)
        self.cache[inp] = outcome
        return outcome
\end{python}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Actually reducing 1}
\begin{changemargin}{2cm}
    Here is the outer loop for delta debugging.
\end{changemargin}
\begin{python}
class DeltaDebuggingReducer(CachingReducer):
  def reduce(self, inp: str) -> str:
    self.reset()
    assert self.test(inp) != Runner.PASS

    n = 2     # Initial granularity
    while len(inp) >= 2:
      start = 0.0
      subset_length = len(inp) / n
      some_complement_is_failing = False
      # inner loop goes here
      
\end{python}
\begin{changemargin}{2cm}
We initialize \texttt{n} to specify that we divide the
input into halves at first.\\[1em]
Also, we set the subset length to the current input length,
divided by \texttt{n}.
\end{changemargin}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Actually reducing 2}
\begin{changemargin}{2cm}
Now the inner loop:    
\end{changemargin}
\begin{python}
      # remove chunks of size len(inp)/n
      while start < len(inp):
          complement = inp[:int(start)] + \
              inp[int(start + subset_length):]
          if self.test(complement) == Runner.FAIL:
              # save the failing test, decrease n
              inp = complement
              n = max(n - 1, 2)
              some_complement_is_failing = True
              break
          start += subset_length
      if not some_complement_is_failing:
          # all subtests pass, get half-as-small chunks.
          if n == len(inp):
              break
          n = min(n * 2, len(inp))
    return inp
\end{python}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Running the delta debugger}
\begin{python}
dd_reducer = DeltaDebuggingReducer(mystery, log_test=True)
dd_reducer.reduce(failing_input)
\end{python}
\begin{changemargin}{2cm}
and there is an example run in the \emph{Fuzzing Book},
which I'll show excerpts from:
\end{changemargin}
\scriptsize
\begin{verbatim}
Test #1 ' 7:,>((/$$-/->.;.=;(.%!:50#7*8=$&&=$9!%6(4=&69\':\'<3+0-3.24#7=!&60)2/+";+<7+1<2!4$>92+$1<(3%&5\'\'>#' 97 FAIL
Test #2 '\'<3+0-3.24#7=!&60)2/+";+<7+1<2!4$>92+$1<(3%&5\'\'>#' 49 PASS
Test #3 " 7:,>((/$$-/->.;.=;(.%!:50#7*8=$&&=$9!%6(4=&69':" 48 PASS
Test #4 '50#7*8=$&&=$9!%6(4=&69\':\'<3+0-3.24#7=!&60)2/+";+<7+1<2!4$>92+$1<(3%&5\'\'>#' 73 FAIL
Test #5 "50#7*8=$&&=$9!%6(4=&69':<7+1<2!4$>92+$1<(3%&5''>#" 49 PASS
Test #6 '50#7*8=$&&=$9!%6(4=&69\':\'<3+0-3.24#7=!&60)2/+";+' 48 FAIL
...
Test #23 '(460)' 5 FAIL
Test #24 '460)' 4 PASS
Test #25 '(0)' 3 FAIL
Test #26 '0)' 2 PASS
Test #27 '(' 1 PASS
Test #28 '()' 2 FAIL
Test #29 ')' 1 PASS
'()'
\end{verbatim}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Solving the mystery}
  \Large
\begin{changemargin}{2cm}
Answer: system fails on an input with a
\texttt{(} and then a \texttt{)}.
\end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Delta debugger commentary}
\begin{changemargin}{2cm}
  Wouldn't want to do this manually on this input:\\
  \qquad random input is harder
  to understand than a human-generated one.\\[1em]

  Assuming that the system is deterministic, we
  can run the algorithm and get the answer. \\[1em]
  Also assume: test cases can run quickly enough
  that we can afford dozens of iterations. \\[1em]

  These are the same conditions as for fuzzing to work well.\\[1em]
\end{changemargin}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Commentary continued}
  \Large
\begin{changemargin}{2cm}
  Implementation checks that the initial test case does fail.\\[1em]

  Delta debugging is best-case $O(\mathrm{log} n)$ and worst-case $O(n^2)$.
\end{changemargin}
\end{frame}


\begin{frame}
  \frametitle{Minimality}
  \Large
\begin{changemargin}{2cm}  
  We get a 1-minimal test case: \\
  removing any character is guaranteed to not fail.\\[1em]
  In the example, we see that the single-paren cases pass.\\[1em]
  This is a local minimum: 
might be some other smaller test case that one would reach with
different choices.
\end{changemargin}
\end{frame}

\begin{frame}
  \frametitle{Advantages of minimality}
  \Large
\begin{changemargin}{1cm}  
\begin{itemize}
\item reduces cognitive load for the programmer: \\
  no irrelevant details, easier to understand what's happening.
\item easier to communicate: \\
  ``\texttt{MysteryRunner} fails on "\texttt{()}"'' vs
  ``\texttt{MysteryRunner} fails on 4100-character input (attached)'' 
\item helps identifying duplicates (to some extent---
  assuming failure has a single cause).
\end{itemize}
\end{changemargin}
\end{frame}

\part{Reducing Inputs, but With Grammars}
\begin{frame}
  \partpage
\end{frame}

\begin{frame}
  \frametitle{Motivation}
  \Large
\begin{changemargin}{2cm}  
  Grammar-Based Reduction: GRABR\\[1em]

  Another application of grammars.\\[1em]

  Structured input languages, \\
  e.g. conforming to a grammar,\\
  \qquad may not work well with delta debugging.\\[1em]
  Idea: Use the grammar to drive reductions.
\end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Delta Debugging \& Expressions}
  \Large
\begin{python}
>>> expr_input = "1 + (2 * 3)"
>>> dd_reducer = DeltaDebuggingReducer(mystery, log_test=True)
>>> dd_reducer.reduce(expr_input)
\end{python}

\begin{changemargin}{2cm}  
This works, but almost all of the substrings aren't
valid expressions.
\end{changemargin}
\begin{verbatim}
Test #2 '2 * 3)' 6 PASS
Test #3 '1 + (' 5 PASS
...
Test #13 '()' 2 FAIL
Test #14 ')' 1 PASS
Test #15 '(' 1 PASS
\end{verbatim}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Modelling a Program}
  \Large
  \begin{changemargin}{2cm}
    Situation: program immediately rejects invalid expressions.\\[1em]
    We model this with a contrived \texttt{Runner}:
\begin{python}
class EvalMysteryRunner(MysteryRunner):
  def __init__(self) -> None:
      self.parser = EarleyParser(EXPR_GRAMMAR)

  def run(self, inp: str) -> Tuple[str, Outcome]:
      try:
          tree, *_ = self.parser.parse(inp)
      except SyntaxError:
          return (inp, Runner.UNRESOLVED)
      return super().run(inp)
\end{python}
i.e. we get no information from an expression that doesn't parse.
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Delta Debugging Utterly Fails}
\begin{verbatim}
>>> expr_input = "1 + (2 * 3)"
>>> dd_reducer = DeltaDebuggingReducer(eval_mystery, log_test=True)
... dd_reducer.reduce(expr_input)
Test #1 '1 + (2 * 3)' 11 FAIL
Test #2 '2 * 3)' 6 UNRESOLVED
Test #3 '1 + (' 5 UNRESOLVED
...
Test #20 '1 + (2 * )' 10 UNRESOLVED
Test #21 '1 + (2 * 3' 10 UNRESOLVED
'1 + (2 * 3)'
\end{verbatim}
  \Large
  \begin{changemargin}{2cm}
    Zero of 20 attempts to reduce parse. \\
    Delta debugging gives us nothing.
  \end{changemargin}
\end{frame}

\begin{frame}
  \frametitle{Delta Debugging and Validity Constraints}
  \Large
  \begin{changemargin}{2cm}
    \texttt{EvalMysteryRunner} imposed a reasonable validity constraint on inputs---an input must be
    a valid expression.\\[1em]
    Invalid inputs are valuable for fuzzing,\\
    but not useful for reducing inputs.\\[1em]
    For reducing: want to give the runner something it can usually work with.
  \end{changemargin}
\end{frame}

\begin{frame}
  \frametitle{Delta Debugging and Validity Constraints}
  \Large
  \begin{changemargin}{2cm}
    \texttt{EvalMysteryRunner} imposed a reasonable validity constraint on inputs---an input must be
    a valid expression.\\[1em]
    Invalid inputs are valuable for fuzzing,\\
    but not useful for reducing inputs.\\[1em]
    For reducing: want to give the runner something it can usually work with.
  \end{changemargin}
\end{frame}

\begin{frame}
  \frametitle{Overview: Grammar-based Reduction}
  \Large
  \begin{changemargin}{2cm}
    Main idea: reduce by replacing subtrees with smaller subtrees.\\[1em]
    Implication: have a syntactically valid tree at all times.
  \end{changemargin}
\end{frame}


\begin{frame}
  \frametitle{Implementing Grammar-based Reduction}
  \Large
  \begin{changemargin}{2cm}
    Two ideas:
    \begin{itemize}
    \item ``Substitution by subtrees'': e.g. replace an \brac{expr} with a smaller \brac{expr}.
    \item ``Simplifying by replacing subtrees'': e.g. replace a \brac{term} which is \texttt{\brac{factor} * \brac{term}} by its alternative \brac{factor}.
    \end{itemize}
  \end{changemargin}
\end{frame}

\begin{frame}
  \frametitle{(1) Substitution by subtrees}
  \Large
  \begin{changemargin}{2cm}
    This is a like-for-like substitution.\\[1em]
    e.g.
    \begin{center}
      \texttt{1 + (2 * 3)} $\Rightarrow$ \texttt{(2 * 3)}
    \end{center}
~\\
    Replace the dark-green \brac{expr} by smaller \brac{expr}:\\[1em]
  \end{changemargin}
\begin{center}
\scalebox{.6}{\begin{tikzpicture}[node distance=1.3cm]
  \node[bt,text width=2.5cm] (s)               {\brac{start}};
  \node[bt,fill=green!50,text width=2cm] (e0) [below of=s] {\brac{expr}};
  \node[bt,text width=1cm,fill=green!20] (+) [below of=e0] {+};
  \node[bt] (t) [left of=+,xshift=-1cm] {\brac{term}};
  \node[bt] (e1) [right of=+,xshift=1cm] {\brac{expr}};

  \path[->] (s) edge node {} (e0);
  \path[->] (e0) edge node {} (t);
  \path[->] (e0) edge node {} (+);
  \path[->] (e0) edge node {} (e1);
\end{tikzpicture} }
\end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Substitution code}
\begin{python}
  import copy
  expr_input = "1 + (2 * 3)"
  derivation_tree, *_ = EarleyParser(EXPR_GRAMMAR).parse(expr_input)
  new_derivation_tree = copy.deepcopy(derivation_tree)
  sub_expr_tree = new_derivation_tree[1][0][1][2]
  new_derivation_tree[1][0] = sub_expr_tree
  all_terminals(new_derivation_tree)
\end{python}
\end{frame}

\begin{frame}
  \frametitle{Other substitution by subtrees}
  \Large
  \begin{changemargin}{2cm}
    We only substitute by subtrees already in the tree.\\[1em]
    The two allowed substitutions for \brac{expr}:
    \begin{center}
      \texttt{1 + (2 * 3)} $\Rightarrow$ \texttt{(2 * 3)}\\
      \texttt{1 + (2 * 3)} $\Rightarrow$ \texttt{2 * 3}
    \end{center}
    Arbitrary replacement of \brac{expr} with non-\brac{expr} likely violates the grammar.
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{EXPR Grammar Reminder}
  \Large
  \begin{python}
    "<term>":
        ["<factor> * <term>", "<factor> / <term>", "<factor>"],
  \end{python}
\end{frame}

\begin{frame}
  \frametitle{(2) Simplifying by Replacing Subtrees}
  \Large
  \begin{changemargin}{2cm}
    More complicated than substitution. \\
    e.g. have \texttt{\brac{term} = 2 * 3}\\ which is \texttt{\brac{factor} * \brac{term}}.\\[1em]
    \brac{term} can be just \brac{factor}.\\
    Remove the \texttt{\brac{factor} * \brac{term}} and put in \texttt{\brac{factor} = 3}.\\[1em]
  \end{changemargin}
    \begin{center}
      \texttt{1 + (2 * 3)} $\Rightarrow$ \texttt{1 + (3)}
    \end{center}
\end{frame}

\begin{frame}
  \frametitle{Carrying out GRABR}
  \Large
  \begin{changemargin}{2cm}
    Goal: replace derivation subtrees by smaller subtrees,\\
    and alternatives with smaller subtrees, \\
    thus simplifying the input.\\[1em]
    But: which strategy---(1) or (2)---when?
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{About the implementation}
\begin{python}
class GrammarReducer(CachingReducer):
    def __init__(self, runner: Runner, parser: Parser, *,
             log_test: bool = False, log_reduce: bool = False):
        # ...

    def subtrees_with_symbol(self, tree: DerivationTree,
                         symbol: str, depth: int = -1,
                         ignore_root: bool = True) 
                 -> List[DerivationTree]:
        # straightforward tree traversal
\end{python}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Using \texttt{subtrees\_with\_symbol()}}

  \Large
  \begin{changemargin}{1cm}
    \texttt{subtrees\_with\_symbol} 
    is the main part of the substitution strategy and
    also used in simplifying.\\[1em]
    Here's all the \brac{term}s in our expression:
  \end{changemargin}
\begin{python}
>>> expr_input = "1 + (2 * 3)"
>>> derivation_tree, *_ = EarleyParser(EXPR_GRAMMAR).parse(expr_input)
>>> grammar_reducer = GrammarReducer(
      mystery,
      EarleyParser(EXPR_GRAMMAR),
      log_reduce=True)
>>> [all_terminals(t) for t in grammar_reducer.subtrees_with_symbol(
      derivation_tree, "<term>")]
['1', '(2 * 3)', '2 * 3', '3']
\end{python}
  \begin{changemargin}{1cm}
We use it to find candidates to replace with.
  \end{changemargin}

\end{frame}

\begin{frame}[fragile]
  \frametitle{How \texttt{alternate\_reductions()} works}

  \Large
  \begin{changemargin}{2cm}
    Say we have \brac{x}, and grammar says.\\[1em]
    \[ \brac{x} ::= Y \mid Z \]
    
Then: construct $Y$s and $Z$s using candidates we find in the tree;
return the shortest $Y$ and the shortest $Z$ we can construct.
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Using \texttt{alternate\_reductions()}}

  \Large
  \begin{changemargin}{1cm}
    Here we print all alternate reductions for \brac{term}:
  \end{changemargin}
\begin{python}
>>> grammar_reducer.try_all_combinations = True
>>> print([all_terminals(t)
       for t in grammar_reducer.alternate_reductions
                       (derivation_tree, "<term>")])
['1', '2', '3', '1 * 1', '1 * 3', '2 * 1', '2 * 3', '3 * 1', '3 * 3', '(2 * 3)', '1 * 2 * 3', '2 * 2 * 3', '3 * 2 * 3', '1 * (2 * 3)', '(2 * 3) * 1', '(2 * 3) * 3', '2 * (2 * 3)', '3 * (2 * 3)']
\end{python}
\begin{changemargin}{1cm}
  Includes: all possible \brac{digit}s in the tree, plus
  \texttt{\brac{factor} * \brac{term}},
  with the \brac{factor}s and \brac{term}s already in the tree.
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Without \texttt{try\_all\_combinations}}

  \Large
  \begin{changemargin}{1cm}
Returns the shortest
\brac{factor} and the shortest \texttt{\brac{factor} * \brac{term}}.\\[1em]
There is no \texttt{\brac{factor} / \brac{term}} in the tree.
  \end{changemargin}
\begin{python}
>>> grammar_reducer.try_all_combinations = False
>>> print([all_terminals(t)
       for t in grammar_reducer.alternate_reductions
                       (derivation_tree, "<term>")])
['1', '1 * 1']
\end{python}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Combining Strategies}

  \Large
  \begin{changemargin}{1cm}
    Why not both?\\[1em]
    We collect results from substitution and simplifying,
    combine, and deduplicate.
  \end{changemargin}
  \begin{python}
    def symbol_reductions(self, tree: DerivationTree, 
                          symbol: str, 
                          depth: int = -1):
        reductions = (self.subtrees_with_symbol(tree, symbol, depth=depth)
                      + self.alternate_reductions(tree, symbol, 
                                depth=depth))
        # Filter duplicates and put into unique_reductions      [... omitted]
        return unique_reductions
  \end{python}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Running the Code: \brac{expr}}

  \Large
  \begin{changemargin}{1cm}
Recall: \brac{expr} is either ``\texttt{\brac{term} + \brac{expr}}'', or ``\brac{term}''.
\begin{python}
>>> print ([all_terminals(t) for t in grammar_reducer.subtrees_with_symbol(derivation_tree, "<expr>")])
['1 + (2 * 3)', '(2 * 3)', '2 * 3']
>>> print ([all_terminals(t) for t in grammar_reducer.alternate_reductions(derivation_tree, "<expr>")])
['1', '1 + (2 * 3)']
>>> print ([all_terminals(t) for t in grammar_reducer.symbol_reductions(derivation_tree, "<expr>")])
['1 + (2 * 3)', '(2 * 3)', '2 * 3', '1']
\end{python}
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Running the Code: \brac{term}}

  \Large
\begin{python}
>>> print ([all_terminals(t) for t in grammar_reducer.symbol_reductions(derivation_tree, "<term>")])
['1', '(2 * 3)', '2 * 3', '3', '1 * 1']
\end{python}
\begin{changemargin}{1cm}
  The \texttt{1 * 1} is an alternate expansion for \brac{term}.
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Implementation structure: \texttt{reduce\_subtree}}

  \begin{changemargin}{2cm}
    For each child:
    \begin{enumerate}
\item collect the set of \texttt{symbol\_reductions()},
\item check that a reduction is indeed smaller,
\item replace the child with the reduction.
    \end{enumerate}
    If the reduction fails (as desired), continue with reduced tree.\\[1em]
    Recursively reduce children.

  \end{changemargin}
\end{frame}
  
\begin{frame}[fragile]
  \frametitle{GRABR works}
  \begin{changemargin}{2cm}
    We can call the \texttt{reduce()} method,
    which uses some helper functions:
  \end{changemargin}
\begin{python}
>>>  grammar_reducer = GrammarReducer(
       eval_mystery,
       EarleyParser(EXPR_GRAMMAR),
       log_test=True)
>>> grammar_reducer.reduce(expr_input)
Test #1 '(2 * 3)' 7 FAIL
Test #2 '2 * 3' 5 PASS
Test #3 '3' 1 PASS
Test #4 '2' 1 PASS
Test #5 '(3)' 3 FAIL
(3)
\end{python}
  \begin{changemargin}{2cm}
    We get valid output \texttt{(3)} at the end, in 5 steps.\\[1em]
    No \texttt{UNRESOLVED} tests along the way.
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Removing less: using depth}
  \begin{changemargin}{2cm}
    So far: replace subtrees with smallest possible subtrees,\\
    e.g. $\texttt{2 * 3} \rightarrow \texttt{2}$ and then \texttt{3}.\\[1em]
    Delta debugging tries to remove ``sensible'' chunk sizes.\\
    For trees: replace with larger subtrees rather than smaller subtrees.
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Where depth comes in}
  \begin{changemargin}{2cm}
    Subtrees closer to root (smaller depth) are by definition bigger.\\[1em]
    
\texttt{subtrees\_with\_symbol()} takes \texttt{depth}
parameter---only return subtrees at the given depth.\\[1em]

Search starting with depth 0 and increase;\\
hence, preferentially start with bigger subtrees.
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Depth at work}
\begin{python}
>>>  grammar_reducer = GrammarReducer(
       eval_mystery,
       EarleyParser(EXPR_GRAMMAR),
       log_test=True)
>>> grammar_reducer.reduce_tree = grammar_reducer.reduce_tree_with_depth
>>> grammar_reducer.reduce(expr_input)
Test #1 '(2 * 3)' 7 FAIL
Test #2 '(3)' 3 FAIL
Test #3 '3' 1 PASS

'(3)'
\end{python}
\begin{changemargin}{2cm}
  Does not try subtrees \texttt{2 * 3} or single-digits.\\
  Replaces top \brac{expr} with \texttt{(2*3)} as before.\\
  Then, replaces \brac{term} by the \brac{factor} ``\texttt{3}''.\\
  \texttt{(3)} is as reduced as possible; 3 steps, not 5.
\end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Grammar-based vs delta debugging}
\begin{python}
long_expr_input = GrammarFuzzer(EXPR_GRAMMAR, min_nonterminals=100).fuzz()
\end{python}

\begin{changemargin}{2cm}
  Use the grammar reducer:
\end{changemargin}
\begin{python}
grammar_reducer = GrammarReducer(eval_mystery, EarleyParser(EXPR_GRAMMAR))
with Timer() as grammar_time:
    print(grammar_reducer.reduce(long_expr_input))
\end{python}
\begin{changemargin}{2cm}
  I ran it and it needed 9 tests, finishing in 0.033s.\\[1em]
Now the delta debugger:
\end{changemargin}
\begin{python}
dd_reducer = DeltaDebuggingReducer(eval_mystery)
with Timer() as dd_time:
    print(dd_reducer.reduce(long_expr_input))
\end{python}
\begin{changemargin}{2cm}
This took 618 tests and took 0.503s.
\end{changemargin}
\end{frame}

\end{document}
