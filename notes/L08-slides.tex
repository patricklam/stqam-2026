\documentclass{beamer}

% TODO: print out https://www.fuzzingbook.org/code/Intro_Testing.py

\usetheme{Boadilla}

%\includeonlyframes{current}

\usepackage{times}
\usefonttheme{structurebold}
\usepackage{listings}

\usepackage{pgf}
\usepackage{tikz}
\usepackage{alltt}
\usepackage[normalem]{ulem}
\usetikzlibrary{arrows}
\usetikzlibrary{automata}
\usetikzlibrary{shapes}
\usepackage{amsmath,amssymb}
\usepackage{rotating}
\usepackage{ulem}
\usepackage{pythonhighlight}

\usetikzlibrary{arrows,automata,shapes}
\tikzstyle{block} = [rectangle, draw, fill=blue!20, 
    text width=5em, text centered, rounded corners, minimum height=2em]
\tikzstyle{bt} = [rectangle, draw, fill=blue!20, 
    text width=4em, text centered, rounded corners, minimum height=2em]

\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, 
do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]''
}

%\setbeamercovered{dynamic}
\setbeamertemplate{footline}[page number]{}
\setbeamertemplate{navigation symbols}{}
\usefonttheme{structurebold}

\title{Software Testing, Quality Assurance \& Maintenance---Lecture 8}
\author{Patrick Lam\\University of Waterloo}
\date{January 30, 2026}

\colorlet{redshaded}{red!25!bg}
\colorlet{shaded}{black!25!bg}
\colorlet{shadedshaded}{black!10!bg}
\colorlet{blackshaded}{black!40!bg}

\colorlet{darkred}{red!80!black}
\colorlet{darkblue}{blue!80!black}
\colorlet{darkgreen}{green!80!black}

\newcommand{\rot}[1]{\rotatebox{90}{\mbox{#1}}}
\newcommand{\gray}[1]{\mbox{#1}}

\newenvironment{changemargin}[1]{% 
  \begin{list}{}{% 
    \setlength{\topsep}{0pt}% 
    \setlength{\leftmargin}{#1}% 
    \setlength{\rightmargin}{1em}
    \setlength{\listparindent}{\parindent}% 
    \setlength{\itemindent}{\parindent}% 
    \setlength{\parsep}{\parskip}% 
  }% 
  \item[]}{\end{list}}



\begin{document}

\usebackgroundtemplate{\tikz\node[opacity=0.1]{\includegraphics[width=\paperwidth]{L02/07172_about_banmochi_ishi_strength_and_grip_testing.JPG}};}
\begin{frame}
  \titlepage
\end{frame}

\usebackgroundtemplate{\tikz\node[opacity=0.3]{\includegraphics[width=\paperwidth]{L04/20241110_001424746_blackbird.jpg}};}
\part{Mutation-Based Fuzzing}
\begin{frame}
  \partpage
\end{frame}
\usebackgroundtemplate{}

\begin{frame}
  \frametitle{Putting things together}

  \Large
  \begin{changemargin}{2em}
    Goal: generate many test cases automatically.\\[1em]
    When we talked about helping human oracles,\\
    we mentioned starting from known inputs.\\[1em]
    \alert{Mutation-based fuzzing}: generate new inputs automatically, by modifying known inputs.
  \end{changemargin}
\end{frame}

\begin{frame}
  \frametitle{Mutation-based fuzzing in practice}

  \Large
  \begin{changemargin}{2em}
    Could just flip bytes in the input.\\[1em]

    Or, parse the input and change some nonterminals in the AST.\\[1em]

    Note: Also need to update checksums to see anything interesting.
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Example: URLs}

  \Large
  \begin{changemargin}{2em}
A valid URL looks like this:
\begin{center}
  \small
\begin{verbatim}
    scheme://netloc/path?query#fragment
\end{verbatim}
\end{center}

There is a definition of valid vs invalid URLs (RFC 3986).\\[1em]

A program should do something useful with valid URLs and reject invalid URLs.\\[1em]
Let's use fuzzing to generate valid and invalid URLs.

  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{schemes}

  \Large
  \begin{changemargin}{2em}
\begin{center}
  \small
\begin{verbatim}
    scheme://netloc/path?query#fragment
\end{verbatim}
\end{center}
~\\[1em]
There are a fixed number of valid \texttt{scheme}s, defined in the RFC:
\texttt{http}, \texttt{https}, \texttt{file}, etc.

  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Using the urllib library}

  \small
  \begin{changemargin}{2em}
\begin{python}
>>> from typing import Tuple, List
>>> from typing import Callable, Set, Any
>>> from urllib.parse import urlparse

>>> urlparse("http://www.google.com/search?q=fuzzing")
ParseResult(scheme='http', netloc='www.google.com',
  path='/search', params='',
  query='q=fuzzing', fragment='')
\end{python}
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{urllib in ur function}

  \Large
  \begin{changemargin}{2em}
    \begin{python}
def url_consumer(url: str) -> bool:
    supported_schemes = ["http", "https"]
    result = urlparse(url)
    if result.scheme not in supported_schemes:
        raise ValueError("Scheme must be one of " + 
                         repr(supported_schemes))
    if result.netloc == '':
        raise ValueError("Host must be non-empty")

    # Do something with the URL
    return True
    \end{python}
    How to test?
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Naive input generation}

  \Large
  \begin{changemargin}{2em}
  In \texttt{code/L08/random\_inputs.py}:
\begin{python}
  for i in range(1000):
    try:
        fuzzer = Fuzzer()
        url = fuzzer.fuzzer()
        result = url_consumer(url)
        print("Success!")
    except ValueError:
        pass
\end{python}
You'd be very lucky indeed to see Success!.\\[1em]
Basically, this fuzzing won't test anything past validation.
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Being less naive}

  \Large
  \begin{changemargin}{2em}
    Basically two alternatives:
    \begin{itemize}
    \item mutate existing inputs; or,
    \item generate inputs using a grammar.
    \end{itemize}
    ~\\[1em]
    (As mentioned earlier, can also parse/mutate/unparse: higher-level mutation).
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Mutating existing inputs (strings)}
  \begin{python}
import random

def delete_random_character(s: str) -> str:
    """Returns s with a random character deleted"""
    if s == "":
        return s

    pos = random.randint(0, len(s) - 1)
    #print("Deleting", repr(s[pos]), "at", pos)
    return s[:pos] + s[pos + 1:]

def insert_random_character(s: str) -> str:
    """Returns s with a random character inserted"""
    pos = random.randint(0, len(s))
    random_character = chr(random.randrange(32, 127))
    #print("Inserting", repr(random_character), "at", pos)
    return s[:pos] + random_character + s[pos:]
  \end{python}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Mutating existing inputs (strings)}
  \begin{python}
def flip_random_character(s):
    """Returns s with a random bit flipped in a random position"""
    if s == "":
        return s

    pos = random.randint(0, len(s) - 1)
    c = s[pos]
    bit = 1 << random.randint(0, 6)
    new_c = chr(ord(c) ^ bit)
    #print("Flipping", bit, "in", repr(c) + ", giving", repr(new_c))
    return s[:pos] + new_c + s[pos + 1:]
  \end{python}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Running the mutation code}
  \begin{python}
seed_input = "A quick brown fox"
for i in range(10):
    x = delete_random_character(seed_input)
    print(repr(x))

for i in range(10):
    print(repr(insert_random_character(seed_input)))

for i in range(10):
    print(repr(flip_random_character(seed_input)))
  \end{python}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Choose randomness randomly}
  \begin{python}
def mutate(s: str) -> str:
    """Return s with a random mutation applied"""
    mutators = [
        delete_random_character,
        insert_random_character,
        flip_random_character
    ]
    mutator = random.choice(mutators)
    # print(mutator)
    return mutator(s)

for i in range(10):
    print(repr(mutate("A quick brown fox")))
  \end{python}
  ~\\ (\texttt{code/L08/mutator.py})
\end{frame}

\begin{frame}[fragile]
  \frametitle{Back to URLs: retrofitting \texttt{url\_consumer}}
  \begin{python}
from random_inputs import url_consumer

def is_valid_url(url: str) -> bool:
    try:
        result = url_consumer(url)
        return True
    except ValueError:
        return False

assert is_valid_url("http://www.google.com/search?q=fuzzing")
assert not is_valid_url("xyzzy")
  \end{python}
  {\Large \begin{changemargin}{2em}
      Easier to test with this wrapper: \\
      wrapper returns \texttt{True}/\texttt{False}.
    \end{changemargin}}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Using the mutation fuzzer}
  \begin{python}
from mutation_fuzzer import MutationFuzzer

seed_input = "http://www.google.com/search?q=fuzzing"
valid_inputs = set()
trials = 20

mutation_fuzzer = MutationFuzzer([])
for i in range(trials):
    inp = mutation_fuzzer.mutate(seed_input)
    if is_valid_url(inp):
        valid_inputs.add(inp)

print (len(valid_inputs)/trials)
  \end{python}
  \begin{changemargin}{2em}
    \Large What do you observe when you run this?
  \end{changemargin}
\end{frame}

\begin{frame}
  \frametitle{Exercise: \texttt{http} $\rightarrow$ \texttt{https}}

  \Large
  \begin{changemargin}{2em}
    How many trials to expect before randomly mutating \texttt{http} to get \texttt{https}?
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Applying multiple mutations to one input}

  \Large
  \begin{changemargin}{2em}
  Not for mutation analysis, but critical for mutation fuzzing.

\begin{python}
seed_input = "http://www.google.com/search?q=fuzzing"
mutations = 50
inp = seed_input
for i in range(mutations):
    if i % 5 == 0:
        print(i, "mutations:", repr(inp))
    inp = mutation_fuzzer.mutate(inp)
\end{python}
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Encapsulating fuzzing in a class}

  \Large
  \begin{changemargin}{2em}
\begin{python}
class MutationFuzzer(Fuzzer):
    """Base class for mutational fuzzing"""

    def __init__(self, seed: List[str],
                 min_mutations: int = 2,
                 max_mutations: int = 10) -> None
        # ...
    def reset(self) -> None:
        # ...
\end{python}

  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Useful functions}

  \Large
  \begin{changemargin}{2em}
\begin{python}
    def create_candidate(self) -> str:
        """Create a new candidate by mutating a population member"""
        candidate = random.choice(self.population)
        trials = random.randint(self.min_mutations, self.max_mutations)
        for i in range(trials):
            candidate = self.mutate(candidate)
        return candidate

    def fuzz(self) -> str:
        if self.seed_index < len(self.seed):
            # Still seeding
            self.inp = self.seed[self.seed_index]
            self.seed_index += 1
        else:
            # Mutating
            self.inp = self.create_candidate()
        return self.inp
\end{python}

  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Using MutationFuzzer}

  \Large
  \begin{changemargin}{0em}
\begin{python}
>>> seed_input = "http://www.google.com/search?q=fuzzing"
>>> mutation_fuzzer = MutationFuzzer(seed=[seed_input])
>>> print(mutation_fuzzer.fuzz())
>>> print(mutation_fuzzer.fuzz())
>>> print(mutation_fuzzer.fuzz())
http://www.google.com/search?q=fuzzing
http+:R/'ww.google.com/serchql=fuzing
htEtp://wwwgoogld.coi/earch?qn=fung
\end{python}
  \end{changemargin}
\end{frame}

\part{Intermission: Hierarchies}
\begin{frame}
  \partpage
\end{frame}

\usebackgroundtemplate{\tikz\node[opacity=0.3]{\includegraphics[width=\paperwidth]{L08/6367_step_pyramid_with_scaffolding.jpg}};}
\begin{frame}
  \frametitle{On Hierarchies}

    \Large
  \begin{changemargin}{2em}
    We know that randomly changing bytes won't exercise much interesting functionality.\\[1em]
    It can cause crashes, though, at least for a while.\\[1em]
    Let's continue to use randomness, but in a more directed way.
  \end{changemargin}
\end{frame}


\begin{frame}
  \frametitle{Hierarchy of inputs: C}
  \begin{changemargin}{1em}
    C programs are way more structured than URLs.
\begin{enumerate}
\item sequence of ASCII characters;
\item sequence of words, separators, and white space (gets past the lexer);
\item syntactically correct C program (gets past the parser);
\item type-correct C program (gets past the type checker);
\item statically conforming C program (starts to exercise optimizations);
\item dynamically conforming C program;
\item model conforming C program.
\end{enumerate}
~\\[1em]
Each level is a subset of previous level, but more likely to find interesting inputs specific to the system.\\[1em]
Operate at all the levels.
  \end{changemargin}
\end{frame}

\begin{frame}
  \frametitle{Generating higher-level inputs}

  \Large
  \begin{changemargin}{2em}
    Two choices:
    \begin{enumerate}
    \item use grammars (context-free grammars still don't satisfy all constraints)
    \item modify existing inputs (as seen above)
    \end{enumerate}

    ~\\[1em]
    This is true for all generational fuzzing tools. \\
    Need to incorporate knowledge about correct syntax.
  \end{changemargin}
\end{frame}
\usebackgroundtemplate{}

\part{Guiding by Coverage}
\begin{frame}
  \partpage
\end{frame}

\usebackgroundtemplate{\tikz\node[opacity=0.3]{\includegraphics[width=\paperwidth]{L08/00296_bunny_v1.jpg}};}
\begin{frame}
  \frametitle{AFL's big idea}

  \Large
  \begin{changemargin}{2em}
    So far: use coverage to evaluate test suites.\\[1em]
    New: \alert{greybox fuzzing} = use coverage to guide test generation (used in AFL, with some more twists).
  \end{changemargin}
\end{frame}
\usebackgroundtemplate{}

\begin{frame}
  \frametitle{How AFL gathers coverage information}

  \Large
  \begin{changemargin}{2em}
    In Python: use language features to measure coverage.\\[1em]

    AFL: rewrite assembly code, adding instrumentation to collect branch counts.\\[1em]

    AFL can also collect coverage information from a virtual machine (QEMU) or dynamic instrumentation (pintools).
  \end{changemargin}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Infrastructure}
  \begin{changemargin}{2em}
\begin{python}
class Runner:
    """Base class for testing inputs."""

    # Test outcomes
    PASS = "PASS"
    FAIL = "FAIL"
    UNRESOLVED = "UNRESOLVED"

    def __init__(self) -> None:
        """Initialize"""
        pass

    def run(self, inp: str) -> Any:
        """Run the runner with the given input"""
        return (inp, Runner.UNRESOLVED)
\end{python}
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Instantiating infrastructure}
  \begin{changemargin}{2em}
\begin{python}
class FunctionRunner(Runner):
    def __init__(self, function: Callable) -> None:
        self.function = function

    def run_function(self, inp: str) -> Any:
        return self.function(inp)

    def run(self, inp: str) -> Tuple[Any, str]:
        try:
            result = self.run_function(inp)
            outcome = self.PASS
        except Exception:
            result = None
            outcome = self.FAIL
        return result, outcome
\end{python}
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Running the FunctionRunner}
  \begin{changemargin}{2em}
\begin{python}
from fuzzer import Runner
from random_inputs import url_consumer
from urllib.parse import urlparse
    
if __name__ == "__main__":
    # view output from urlconsumer_runner:
    urlconsumer_runner = FunctionRunner(url_consumer)
    print (urlconsumer_runner.run("https://foo.bar"))
\end{python}

Output: \texttt{(True, 'PASS')}
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Measuring Coverage in the Runner}
  \begin{changemargin}{2em}
\begin{python}
class FunctionCoverageRunner(FunctionRunner):
    def run_function(self, inp: str) -> Any:
        with Coverage() as cov:
            try:
                result = super().run_function(inp)
            except Exception as exc:
                self._coverage = cov.coverage()
                raise exc

        self._coverage = cov.coverage()
        return result

    def coverage(self) -> Set[Location]:
        return self._coverage
\end{python}
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Running \texttt{function\_coverage\_runner.py}}
  \begin{changemargin}{2em}
\begin{python}
if __name__ == "__main__":
    from urllib.parse import urlparse

    # view output from urlconsumer_runner:
    urlconsumer_runner = FunctionCoverageRunner(url_consumer)
    urlconsumer_runner.run("https://foo.bar")

    print(list(urlconsumer_runner.coverage())[:5])
\end{python}
prints a slice of the coverage:
{\small \begin{verbatim}
  [('url_consumer', 7), ('_splitnetloc', 416),
    ('_splitnetloc', 419), ('urlsplit', 502),
    ('urlsplit', 499)]
\end{verbatim} }
  \end{changemargin}
\end{frame}

\begin{frame}
  \frametitle{Putting the AFL Idea into Practice: Greybox Fuzzing}

  \Large
  \begin{changemargin}{2em}
    Maintain a population of source inputs.\\[1em]
    The mutation fuzzer (from Part I) mutates inputs in the population to generate new candidate inputs and always adds them.\\[1em]
    \alert{Greybox Fuzzing}: Add an input to the population when that input adds to coverage.\\[1em]
  \end{changemargin}
\end{frame}

\usebackgroundtemplate{\tikz\node[opacity=0.3]{\includegraphics[width=\paperwidth]{L08/20190324_095746174_boxes.jpg}};}
\begin{frame}
  \frametitle{Why greybox?}

  \Large
  \begin{changemargin}{2em}
    Blackbox: don't look at the implementation at all.\\[1em]
    Whitebox: use the implementation to guide testing.\\[1em]
    Greybox: use coverage to guide testing, but don't look at the implementation itself.
  \end{changemargin}
\end{frame}
\usebackgroundtemplate{}

\begin{frame}[fragile]
  \frametitle{\texttt{MutationCoverageFuzzer} implementation}
\begin{python}
class MutationCoverageFuzzer(MutationFuzzer):
    def reset(self) -> None:
        super().reset()
        self.coverages_seen: Set[frozenset] = set()
        self.population = []

    def run(self, runner: FunctionCoverageRunner) -> Any:
        """Run function(inp) while tracking coverage.
           If we reach new coverage,
           add inp to population and its coverage to population_coverage
        """
        result, outcome = super().run(runner)
        new_coverage = frozenset(runner.coverage())
        if outcome == Runner.PASS and new_coverage not in self.coverages_seen:
            self.population.append(self.inp)
            self.coverages_seen.add(new_coverage)

        return result
\end{python}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The population}
  \begin{python}
if __name__ == "__main__":
    seed_input = "http://www.google.com/search?q=fuzzing"
    mutation_coverage_fuzzer = MutationCoverageFuzzer(seed=[seed_input])
    urlconsumer_runner = FunctionCoverageRunner(url_consumer)
    mutation__coverage_fuzzer.runs(urlconsumer_runner, trials=10000)
    print (mutation_fuzzer.population)
  \end{python}
  We aim to increase coverage of \texttt{url\_consumer} and the functions it calls.
  The population after 10,000 trials:
  {\scriptsize
    \begin{verbatim}
      ['http://www.google.com/search?q=fuzzing',
        'http://www.google|.com/search\x7fq=fuZzing',
        'http://ww;w.google|.com/searc\x7f=fuZzing#',
        'http://ww;w?.gogle|com/sEarc\x7f=f,uZzig#',
        "http://www.googla|.com'sarch\x7fq9fuZzi!ng",
        'http://ww;wgoole|/com/sear;c\x7ffuZzing#',
        'http://wg;wgoole|m/cnmb/suar;cwfuZzing\x03',
        'http://wg;wgoole|m/cnmb/suar;cwfuZzing\x03',
        'http://wgW;wgoole|m/cnmb/s}ar;cwfuZz-ing\x03/:',
        'http://wgW;wgoole|m/cnmb/s}ar;cwfuZz?-qing\x03/:',
        'Http://wg5W;\x7fgoorle|amcmb/S}ar;cwfuZz?-qing#\x03/:',
        'Http://wg5W;\x7fgoOrle|!mcmb/S}ap;cwfuZj/-qing#/:']
\end{verbatim}
    }

\end{frame}

\begin{frame}
  \frametitle{Coverage increases}

  \Large
  \begin{changemargin}{2em}
    It is possible to plot coverage-over-time using this strategy;
    see the \emph{Fuzzing Book} for details, but here's a picture from there.\\[1em]
  \end{changemargin}
  \begin{center}
    \includegraphics[width=.6\textwidth]{L08/coverage-increases.png}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Code comprehension exercise}

  \Large
  \begin{changemargin}{2em}
    There's a lot of inheritance in \texttt{MutationCoverageFuzzer}.\\[1em]

    Exercise: How does \texttt{MutationCoverageFuzzer.runs()} work? \\
    Trace the execution
    and form an understanding of how the classes fit together.
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Guiding by Coverage for the win}
  \begin{changemargin}{2em}
    Consider this code to be tested:
\begin{python}
  def crashme(s: str) -> None:
     if len(s) > 0 and s[0] == 'b':
         if len(s) > 1 and s[1] == 'a':
             if len(s) > 2 and s[2] == 'd':
                 if len(s) > 3 and s[3] == '!':
                     raise Exception()
\end{python}
   Resistant to normal mutation fuzzing.
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Trying Mutation Fuzzing}
  \begin{changemargin}{0em}
    \small
\begin{python}
    n=30000
    seed_input="good"
    bb_fuzzer=AdvancedMutationFuzzer([seed_input], Mutator(), PowerSchedule())

    start=time.time()
    bb_fuzzer.runs(FunctionCoverageRunner(crashme), trials=n)
    end=time.time()

    print ("Blackbox mutation-based: %0.2fs for %d inputs." % (end - start, n))
    _, blackbox_coverage = population_coverage(blackbox_fuzzer.inputs, crashme)
    bb_max_coverage = max(blackbox_coverage)
    print ("Blackbox mutation-based: max coverage %d." % bb_max_coverage)
    print ([seed_input] + [\
        blackbox_fuzzer.inputs[idx] for idx in range(len(blackbox_coverage))\
        if blackbox_coverage[idx] > blackbox_coverage[idx-1]\
    ])
\end{python}
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Mutation Fuzzing Results}
  \begin{changemargin}{2em}
    \small
\begin{verbatim}
Blackbox mutation-based: 0.57s for 30000 inputs.
Blackbox mutation-based fuzzer: max coverage 2.
['good', 'boo']
\end{verbatim}
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Adding Greybox: Results}
  \begin{changemargin}{2em}
{\Large    You'll find \texttt{GreyboxFuzzer} in the repo also.\\[1em]}

\begin{verbatim}
Blackbox mutation-based: 0.65s for 30000 inputs.
Blackbox mutation-based fuzzer: max coverage 2.
['good', 'bgodI']
Greybox mutation-based: 0.73s for 30000 inputs.
Greybox mutation-based fuzzer: 3 more.
[good, bgod, bao]Cd, badS, bad!]
\end{verbatim}

~\\
{\Large That's promising: it reaches otherwise-unlikely nested branches.}
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Coverage over time: blackbox vs greybox \\(from Fuzzing Book)}
  \begin{center}
  \includegraphics[height=.8\textheight]{L08/bb-vs-greybox.png}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Coverage-guided fuzzing summary}

  \Large
  \begin{changemargin}{2em}
    Coverage-guided fuzzing (AFL) definitely explores new parts of the program's
    behaviour as it runs.\\[1em]
    Eventually, it hits diminishing returns.
  \end{changemargin}
\end{frame}

\usebackgroundtemplate{\tikz\node[opacity=0.3]{\includegraphics[width=\paperwidth]{L08/07032_powerlines_v1.jpg}};}
\part{Guiding by Coverage with Power}
\begin{frame}
  \partpage
\end{frame}
\usebackgroundtemplate{}

\begin{frame}
  \frametitle{AFL does a bit more than we've said so far}

  \Large
  \begin{changemargin}{2em}
    So far: draw seeds (paths) uniformly at random from population.\\[1em]
    But: some paths more important than others.\\
    Important paths should come up more often.
  \end{changemargin}
\end{frame}

\begin{frame}
  \frametitle{Concept: Power schedule}

  \Large
  \begin{changemargin}{2em}
    \alert{Power schedule}: assigns energy value (floating-point) to each seed in the population.\\[1em]
    Allows the fuzzer to prioritize higher-energy (presumably higher-value) seeds---\\
it randomly selects a seed from the population consistent with energy distribution.
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Power Schedule}
  \begin{changemargin}{0em}
    \small
\begin{python}
class PowerSchedule:
    def __init__(self) -> None:
        self.path_frequency: Dict = {}

    def assignEnergy(self, population: Sequence[Seed]) -> None:
        for seed in population:
            seed.energy = 1

    def normalizedEnergy(self, population: Sequence[Seed]) -> List[float]:
        """omitted for space"""
        pass

    def choose(self, population: Sequence[Seed]) -> Seed:
        """Choose weighted by normalized energy."""
        self.assignEnergy(population)
        norm_energy = self.normalizedEnergy(population)
        seed: Seed = random.choices(population, weights=norm_energy)[0]
        return seed
\end{python}
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Default Power Schedule}
  \begin{changemargin}{0em}
    \small
\begin{python}
if __name__ == "__main__":
    population = [Seed("A"), Seed("B"), Seed("C")]
    schedule = PowerSchedule()
    hits = { "A": 0, "B": 0, "C": 0 }
    for i in range(10000):
        seed = schedule.choose(population)
        hits[seed.data] += 1
    print (repr(hits))
\end{python}
{\Large yields:}
\begin{python}
{'A': 3372, 'B': 3249, 'C': 3379}
\end{python}

  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{\texttt{AdvancedMutationFuzzer}}
  \begin{changemargin}{0em}
    \small
\begin{python}
 def create_candidate(self) -> str:
     """Returns an input generated by fuzzing a seed in the population"""
     seed = self.schedule.choose(self.population) # <--!

     # Stacking: Apply multiple mutations to generate the candidate
     candidate = seed.data
     trials = min(len(candidate), 1 << random.randint(1, 5))
     for i in range(trials):
         candidate = self.mutator.mutate(candidate)
     return candidate
\end{python}

  \end{changemargin}

  \begin{changemargin}{2em}
    \Large
We haven't assigned any energy, so all seeds have energy 1.
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Path IDs}
  \begin{changemargin}{2em}
    \Large
    Want to give unusual paths (those not exercised often) more energy.\\[1em]

    First, define path IDs:
    \small
\begin{python}
import pickle   # serializes an object by producing a byte array from all the information in the object
import hashlib  # produces a 128-bit hash value from a byte array

def getPathID(coverage: Any) -> str:
    """Returns a unique hash for the covered statements"""
    pickled = pickle.dumps(sorted(coverage))
    return hashlib.md5(pickled).hexdigest()
\end{python}

  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{AFL vs AFLFast}
  \begin{changemargin}{2em}
    Original AFL: energy is constant in \# times seed chosen $s(i)$.\\[1em]

    AFLFast: energy exponential in $s(i)$; from that paper:
\begin{minipage}{.9\textwidth}
    \begin{quote}
  When the seed is fuzzed for the first time, very low energy is assigned.
  Every time the seed is chosen thereafter, exponentially more inputs are
  generated up to a certain bound. This allows to rapidly approach the minimum
  energy required to discover a new path.
    \end{quote}
\end{minipage}
    \small
\begin{python}
class AFLFastSchedule(PowerSchedule):
  def assignEnergy(self, population) -> None:
    for seed in population:
      seed.energy = 1 / (self.path_frequency[getPathID(seed.coverage)] ** self.exponent)
\end{python}

  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Counting Greybox Fuzzer}
  \begin{changemargin}{2em}
Adds to path frequency when a path is run:    
\begin{python}
    def run(self, runner: FunctionCoverageRunner) -> Tuple[Any, str]:
        result, outcome = super().run(runner)

        path_id = getPathID(runner.coverage())
        if path_id not in self.schedule.path_frequency:
            self.schedule.path_frequency[path_id] = 1
        else:
            self.schedule.path_frequency[path_id] += 1

        return(result, outcome)  
\end{python}

  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Counting Greybox Fuzzer: Results}
  \begin{changemargin}{0em}
{\small \begin{verbatim}
fuzzer w/ exponential schedule 0.46s for 10000 inputs.
Our fuzzer w/exponential schedule covers 5 statements.
             path id 'p'           : path frequency 'f(p)'
{'26...1854': 5468, 'bc...7bac': 2694,
 '6f...3853': 1119, 'f7...57a8': 452,
 '86...bbb5': 267}
fuzzer w/ original schedule 0.30s for 10000 inputs.
             path id 'p'           : path frequency 'f(p)'
{'26...1854': 7538, 'bc...7bac': 2121,
 '6f...3853': 327,  'f7...57a8': 14}
\end{verbatim}
}
~\\
Exponential is a bit slower than original, but more consistently hits 5 paths.
Original schedule has low count for 5th path.
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Counting Greybox Fuzzer: Normalized Energy}
  \begin{changemargin}{2em}
{\scriptsize \begin{verbatim}
fast schedule:
'26b4becfdd3a8aacb81607a627bd1854', 0.00000, 'good'
'bc2fa870f15bb877d04c81e7bef87bac', 0.00000, 'boodVP'
'6f2492ce0367e22be7f8327c8e333853', 0.00003, 'baooDvP'
'f7b00fe99a9c688bbd30df9e747557a8', 0.03650, 'badvP'
'8669eeece2269c362bfa8d147565bbb5', 0.96347, 'bad!t8D'
original schedule:
'26b4becfdd3a8aacb81607a627bd1854', 0.25000, 'good'
'bc2fa870f15bb877d04c81e7bef87bac', 0.25000, 'bgoodQ'
'6f2492ce0367e22be7f8327c8e333853', 0.25000, 'baJ g6poodP'
'f7b00fe99a9c688bbd30df9e747557a8', 0.25000, 'badN g6poodP'
\end{verbatim}
}
~\\
Unusual path gets the vast majority of the energy under fast schedule; \\
 all paths have same energy under the original schedule.
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Another example: HTMLParser}
  \begin{changemargin}{0em}
\begin{python}
from html.parser import HTMLParser

def my_parser(inp:str) -> None:
    parser = HTMLParser()
    parser.feed(inp)
\end{python}

  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Results}
  \begin{changemargin}{0em}
    Starting with $n = 5000$; single seed with one space.

{\small \begin{verbatim}
It took all three fuzzers 14.77s for 5000 inputs.
Maximum coverages: 65, 165, 168.
Last 10 blackbox:
[' 0', '\x00', '', '', ' /', ' +', '', 'X ', '', '\x00']
Last 10 greybox:
['', '6uJ(', '&6D+G<\x1b!G(', '1&x<$<<n>', '~\x0ek\n#\\<', 'z<<`', '="8!\x01', '1:&9<[8)<?!x',
 '\x15L:a&$T<', '<|']
Last 10 counting greybox:
['>W//<', 'W!<E-/~><?<V', ']\nCNL\x0eD>j<v', '\x1cZ./8\x1f5?$YIN)', 'N$<><Y1!Ie', 
 "z|i\x0c6'}><", 'N,\x1c/?5><!I', '%V^Mo5&n<>+.j<', '>N\rP5!G>', 'PXRCnb+/']
\end{verbatim}
}
  \end{changemargin}
\end{frame}

\begin{frame}
  \frametitle{Coverage over time (from Fuzzing Book)}

  \Large
  \begin{center}
    \includegraphics[width=.6\textwidth]{L08/bg-gb-bb.png}
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{HTMLParser: comments}
  \begin{changemargin}{2em}
    Coverage:
\begin{itemize}
  \item counting greybox does a bit better than the greybox;
  \item greybox does a lot better than the blackbox;
\end{itemize}
~\\
Inputs:
\begin{itemize}
  \item  blackbox doesn't find much;
  \item greybox includes brackets;
    \item counting greybox includes longer inputs.
\end{itemize}
~\\
Still, even the counting greybox fuzzer \\
doesn't have keywords like \verb+<html>+. \\
We'll need to involve grammars to do that.
  \end{changemargin}
\end{frame}


\usebackgroundtemplate{\tikz\node[opacity=0.3]{\includegraphics[width=\paperwidth]{L08/00296_bunny_v1.jpg}};}
\part{Bonus: more AFL content}
\begin{frame}
  \partpage
\end{frame}
\usebackgroundtemplate{}


\begin{frame}[fragile]
  \frametitle{AFL with Dictionaries}
  \begin{changemargin}{2em}
    Next topic is grammars, but dictionaries of tokens are easier.\\[1em]

    From what I understand:
\begin{itemize}
  \item accept a list of input tokens;
  \item ``mindlessly clobber the tokens together''.
\end{itemize}
Combined with coverage-guided approach: finds more-interesting inputs.\\[1em]
Application: worked on \texttt{sqlite}.
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{AFL with a corpus}
  \begin{changemargin}{2em}
    Further followup: using \texttt{sqlite} test cases as seeds for AFL.\\[1em]
    Also: use \texttt{afl-cmin} and \texttt{afl-tmin} to minimize test cases (we'll see minimization soon).\\[1em]
    Using provided test suites works much better than using a single test case as seed.\\[1em]
    This improvement is for \texttt{sqlite}, which had previously been fuzzed, too.
    
  \end{changemargin}
\end{frame}



\end{document}
