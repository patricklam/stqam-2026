\documentclass{beamer}

% TODO: print out https://www.fuzzingbook.org/code/Intro_Testing.py

\usetheme{Boadilla}

%\includeonlyframes{current}

\usepackage{times}
\usefonttheme{structurebold}
\usepackage{listings}

\usepackage{pgf}
\usepackage{tikz}
\usepackage{alltt}
\usepackage[normalem]{ulem}
\usetikzlibrary{arrows}
\usetikzlibrary{automata}
\usetikzlibrary{shapes}
\usepackage{amsmath,amssymb}
\usepackage{rotating}
\usepackage{ulem}
\usepackage{pythonhighlight}

\usetikzlibrary{arrows,automata,shapes}
\tikzstyle{block} = [rectangle, draw, fill=blue!20, 
    text width=5em, text centered, rounded corners, minimum height=2em]
\tikzstyle{bt} = [rectangle, draw, fill=blue!20, 
    text width=4em, text centered, rounded corners, minimum height=2em]

\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, 
do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]''
}

%\setbeamercovered{dynamic}
\setbeamertemplate{footline}[page number]{}
\setbeamertemplate{navigation symbols}{}
\usefonttheme{structurebold}

\title{Software Testing, Quality Assurance \& Maintenance---Lecture 9}
\author{Patrick Lam\\University of Waterloo}
\date{February 2, 2026}

\colorlet{redshaded}{red!25!bg}
\colorlet{shaded}{black!25!bg}
\colorlet{shadedshaded}{black!10!bg}
\colorlet{blackshaded}{black!40!bg}

\colorlet{darkred}{red!80!black}
\colorlet{darkblue}{blue!80!black}
\colorlet{darkgreen}{green!80!black}

\newcommand{\rot}[1]{\rotatebox{90}{\mbox{#1}}}
\newcommand{\gray}[1]{\mbox{#1}}

\newenvironment{changemargin}[1]{% 
  \begin{list}{}{% 
    \setlength{\topsep}{0pt}% 
    \setlength{\leftmargin}{#1}% 
    \setlength{\rightmargin}{1em}
    \setlength{\listparindent}{\parindent}% 
    \setlength{\itemindent}{\parindent}% 
    \setlength{\parsep}{\parskip}% 
  }% 
  \item[]}{\end{list}}

\newcommand{\brac}[1]{\texttt{\textless #1\textgreater}}


\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\usebackgroundtemplate{\tikz\node[opacity=0.3]{\includegraphics[width=\paperwidth]{L09/20221207_043128075_auckland_grammar_school.jpg}};}
\part{Intro: Grammar-Based Fuzzing}
\begin{frame}
  \partpage
\end{frame}
\usebackgroundtemplate{}

\begin{frame}
  \frametitle{Types of Fuzzing}

  \Large
  \begin{changemargin}{2em}
    Goal: generate many test cases automatically.\\[1em]
    Mutation-based fuzzing: generate new inputs automatically, by modifying known inputs.\\[1em]
    \alert{Grammar-based fuzzing}: generate new inputs automatically, using a grammar.
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Example: Regular expression}

  \Large
  \begin{changemargin}{2em}
    \begin{center}
\begin{verbatim}
  ^4[0-9]{12}(?:[0-9]{3})?$
\end{verbatim}
    \end{center}
~\\
Uses:
\begin{itemize}
\item check if a number is valid
\item \alert{generate} numbers of the right shape
\end{itemize}
(But: also must satisfy checksum rules!)
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Checksum rules for credit card numbers}

  \Large
  \begin{changemargin}{1em}
    Luhn algorithm: \\
    \qquad calculate a checksum from all-but-last digits;\\
    \qquad the last digit must match the checksum.\\[1em]
    Can't specify checksum rules as regexp or context-free grammars.
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Example (standard): expressions}

  \Large
  \begin{changemargin}{2em}
    Context-free grammars (CFGs):
  \end{changemargin}
    \small
\begin{verbatim}
<start>   ::= <expr>
<expr>    ::= <term> + <expr> | <term> - <expr> | <term>
<term>    ::= <term> * <factor> | <term> / <factor>
          |   <factor>
<factor>  ::= +<factor> | -<factor> | (<expr>) | <integer>
          |   <integer>.<integer>
<integer> ::= <digit><integer> | <digit>
<digit>   ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
\end{verbatim}

  \Large
  \begin{changemargin}{2em}
    Can also recognize and generate strings for CFGs.
  \end{changemargin}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Generating from grammars}

  \Large
  \begin{changemargin}{2em}
    What we're doing in this lecture:\\
    \qquad generating (trees and) strings\\
    \qquad from grammars.\\[1em]
    These are more interesting than random sequences of characters;\\
    they test behaviour beyond input validation.\\[1em]
    Aim: create grammars that specify all legal inputs.\\[1em]
    Other uses: configs, APIs, GUIs, etc.
  \end{changemargin}
\end{frame}

\usebackgroundtemplate{\tikz\node[opacity=0.3]{\includegraphics[width=\paperwidth]{L09/20221207_043128075_auckland_grammar_school.jpg}};}
\part{Generating from CFGs}
\begin{frame}
  \partpage
\end{frame}
\usebackgroundtemplate{}


\begin{frame}[fragile]
  \frametitle{Expressiveness}

  \Large
  \begin{center}
    \includegraphics[width=.6\textwidth]{L09/html.png}
  \end{center}
  \begin{changemargin}{2em}
    Regexps can't count (so no HTML parsers).\\
    CFGs can't implement Luhn algorithm.
  \end{changemargin}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Generating Inputs}

  \Large
  \begin{changemargin}{2em}
    How to generate inputs from this grammar?\\[1em]
\begin{verbatim}
<start> ::= <digit><digit>
<digit> ::= 0 | 1 | 2 | 3 | 4
        |   5 | 6 | 7 | 8 | 9
\end{verbatim}
~\\
(Could be expressed as a regexp).\\[1em]
Note: \brac{xxx} represents nonterminal \texttt{xxx}.
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Generating Inputs: double-digits}

  \Large
  \begin{changemargin}{2em}
    \begin{itemize}
      \item \brac{start} $\rightarrow$ \brac{digit}\brac{digit}
      \item visit first \brac{digit}, have 10 choices; \\
        choose randomly, say \texttt{1};\\
        replace \brac{digit} by \texttt{1}.
      \item visit second \brac{digit}, \\ choose say \texttt{7} randomly;\\
        replace \brac{digit} by \texttt{7}.
      \item generated input: \texttt{17}
    \end{itemize}
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Generating Inputs: back to expr}

  \Large
  \begin{changemargin}{2em}
  \end{changemargin}
    \small
\begin{verbatim}
<start>   ::= <expr>
<expr>    ::= <term> + <expr> | <term> - <expr> | <term>
<term>    ::= <term> * <factor> | <term> / <factor>
          |   <factor>
<factor>  ::= +<factor> | -<factor> | (<expr>) | <integer>
          |   <integer>.<integer>
<integer> ::= <digit><integer> | <digit>
<digit>   ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
\end{verbatim}


\end{frame}

\begin{frame}[fragile]
  \frametitle{Generating Inputs: expr}

  \begin{changemargin}{2em}
    \begin{itemize}
      \item \brac{start} $\rightarrow$ \brac{expr}
      \item visit \brac{expr};
        three \brac{expr} alternatives, \\
        randomly choose \brac{term} + \brac{expr}, \\
        replace \brac{expr} by our choice.
      \item visit \brac{term}; 
        also three \brac{term} alternatives,\\
        randomly choose \brac{factor}.
      \item visit \brac{factor}; \\
        randomly choose \brac{integer} of the 5 alternatives.
      \item visit \brac{integer};
        randomly choose \brac{digit};
      \item visit \brac{digit};\\
        randomly choose terminal \texttt{4} and generate it.
      \item continue with next nonterminal \texttt{expr} \ldots
    \end{itemize}
    Could generate, for instance, \texttt{4 + 22 * 5.3}, or many other expressions.
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Coding Things Up: Grammars in Python}

  \Large
  \begin{changemargin}{2em}
    Just use Python data structures.\\[1em]

    Grammar = mapping from an alternative's LHS to its RHS.\\
    Here is a single-production grammar.
\begin{python}
DIGIT_GRAMMAR = {
  "<start>":
    ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]
}
\end{python}

Nonterminals in  \brac{brackets}.\\
Rest of the string interpreted as terminals.\\[1em]
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Python Type Hint for Grammars}

  \Large
  \begin{changemargin}{2em}
\begin{python}
from typing import Dict, List
type Expansion = str
type Grammar = Dict[str, List[Expansion]]
\end{python}

  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Expression Grammar in Python}

  \Large
  \begin{changemargin}{1em}
\begin{python}
EXPR_GRAMMAR: Grammar = {
    "<start>":
        ["<expr>"],
    "<expr>":
        ["<term> + <expr>", "<term> - <expr>", "<term>"],
    "<term>":
        ["<factor> * <term>",
         "<factor> / <term>", "<factor>"],
    "<factor>":
        ["+<factor>", "-<factor>",
         "(<expr>)",
         "<integer>.<integer>", "<integer>"],
    "<integer>":
        ["<digit><integer>", "<digit>"],
    "<digit>":
        ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]
  }
\end{python}
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Playing with Grammars}

  \Large
  \begin{changemargin}{1em}
\begin{python}
>>> EXPR_GRAMMAR["<digit>"]
['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
>>> "<integer>" in EXPR_GRAMMAR
True
\end{python}
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Conventions and Helpers}

  \Large
  \begin{changemargin}{1em}
    Must always have start symbol \brac{start}:
    \begin{python}
START_SYMBOL = "<start>"
    \end{python}

    Because non-terminals always in \brac{brackets}:
    \begin{python}
import re
RE_NONTERMINAL = re.compile(r'(<[^<> ]*>)')
def nonterminals(expansion):
    if isinstance(expansion, tuple):
        # can be a tuple, use first element
        expansion = expansion[0]

    return RE_NONTERMINAL.findall(expansion)

def is_nonterminal(s):
    return RE_NONTERMINAL.match(s)
\end{python}
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Using these Utilities}

  \Large
  \begin{changemargin}{1em}
\begin{python}
>>> nonterminals("<term> * <factor>")
["<term>", "<factor>"]
>>> is_nonterminal("<symbol-1>")
<re.Match object; span=(0, 10), match='<symbol-1>'>
>>> is_nonterminal("<symbol-1")
>>>
\end{python}
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{A Simple Grammar Fuzzer}

  \Large
\begin{python}
def simple_grammar_fuzzer(grammar: Grammar, 
                          start_symbol: str = START_SYMBOL,
                          max_nonterminals: int = 10,
                          max_expansion_trials: int = 100,
                          log: bool = False) -> str:
 """Produce a string from `grammar`.
   `start_symbol`: use a start symbol other than `<start>` (default).
   `max_nonterminals`: the maximum number of nonterminals 
     still left for expansion
   `max_expansion_trials`: maximum # of attempts to produce a string
   `log`: print expansion progress if True"""
\end{python}
\end{frame}

\begin{frame}[fragile]
  \frametitle{It's all strings: implementation}

  \Large
\begin{python}
  term = start_symbol
  expansion_trials = 0
  while len(nonterminals(term)) > 0:
    symbol_to_expand = random.choice(nonterminals(term))
    expansions = grammar[symbol_to_expand]
    expansion = random.choice(expansions)
    new_term = term.replace(symbol_to_expand, expansion, 1)

    if len(nonterminals(new_term)) < max_nonterminals:
        term = new_term
        expansion_trials = 0
    else:
        expansion_trials += 1
        if expansion_trials >= max_expansion_trials:
            raise ExpansionError("Cannot expand " + repr(term))

  return term
\end{python}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Comments on Simple Grammar Fuzzer}

  \Large
  \begin{changemargin}{1em}
    \begin{itemize}
    \item takes a string, finds a nonterminal, replaces with an alternative.
    \item it's all string replacement.
    \item tree manipulations would be better; stay tuned.
    \end{itemize}
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Termination for Simple Grammar Fuzzer}

  \Large
  \begin{changemargin}{1em}
    Let's look at this more closely:
  \end{changemargin}
  \begin{python}
    if len(nonterminals(new_term)) < max_nonterminals:
        term = new_term
        expansion_trials = 0
    else:
        expansion_trials += 1
        if expansion_trials >= max_expansion_trials:
            raise ExpansionError("Cannot expand " + repr(term))

  return term
  \end{python}
  If too many nonterminals after substitution:\\
  \qquad give up on generated string, re-choose.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Grammar: CGI}
\begin{python}
CGI_GRAMMAR: Grammar = {
    "<start>":
        ["<string>"],
    "<string>":
        ["<letter>", "<letter><string>"],
    "<letter>":
        ["<plus>", "<percent>", "<other>"],
    "<plus>":
        ["+"],
    "<percent>":
        ["%<hexdigit><hexdigit>"],
    "<hexdigit>":
        ["0", "1", "2", "3", "4", "5", "6", "7",
            "8", "9", "a", "b", "c", "d", "e", "f"],
    "<other>":  # Actually, could be _all_ letters
        ["0", "1", "2", "3", "4", "5", "a", "b", "c", "d", "e", "-", "_"],
}
\end{python}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Generating CGI strings}
  \Large
\begin{python}
>>> for i in range(10):
...     print(simple_grammar_fuzzer(grammar=CGI_GRAMMAR, max_nonterminals=10))
... 
%e5
+
+3
_1a
e+
%625%ee
%db%df%5d
+44
%4b
+%b8+2
\end{python}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Grammar: URL}
  \begin{python}
URL_GRAMMAR: Grammar = {
    "<start>": ["<url>"],
    "<url>": ["<scheme>://<authority><path><query>"],
    "<scheme>": ["http", "https", "ftp", "ftps"],
    "<authority>":
        ["<host>", "<host>:<port>",
         "<userinfo>@<host>", "<userinfo>@<host>:<port>"],
    "<host>":  # Just a few
        ["patricklam.ca", "www.google.com", "fuzzingbook.com"],
    "<port>": ["80", "8080", "<nat>"],
    "<nat>": ["<digit>", "<digit><digit>"],
    "<digit>":
        ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"],
    "<userinfo>":  # Just one
        ["user:password"],
    "<path>":  # Just a few
        ["", "/", "/<id>"],
    "<id>": ["abc", "def", "x<digit><digit>"],
    "<query>": ["", "?<params>"],
    "<params>": ["<param>", "<param>&<params>"],
    "<param>": ["<id>=<id>", "<id>=<nat>"],
}
  \end{python}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Generating URLs}
  \Large
\begin{python}
>>> for i in range(10):
...     print(simple_grammar_fuzzer(grammar=URL_GRAMMAR, max_nonterminals=10))
...     
https://user:password@www.google.com/abc
http://user:password@fuzzingbook.com/
http://user:password@patricklam.ca/def?x97=60
ftp://user:password@fuzzingbook.com/x60?abc=def
https://patricklam.ca/?x84=31&x95=x12
ftp://www.google.com:1/abc
ftp://user:password@fuzzingbook.com:80/x40?def=6&x12=abc
ftp://user:password@www.google.com
http://user:password@fuzzingbook.com/def?x35=1
ftp://user:password@www.google.com/abc
\end{python}
\begin{changemargin}{2em}
  This isn't all URLs, but we do get better coverage of our chosen subset.\\
  Other examples possible, e.g. book titles (see \emph{Fuzzing Book}).
\end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{On Validity}
\begin{changemargin}{2em}
  If you have a grammar, \\
  \qquad you can generate strings belonging to the grammar \\
  \qquad (as we've seen).\\[1em]
  These strings, by definition, always satisfy the grammar.\\[1em]
  They may not be valid inputs to a program.\\
  \begin{itemize}
  \item e.g. port number between 1024 and 2048;
  \item e.g. checksum digit satisfies Luhn's algorithm.
  \end{itemize}
  ~\\
  Can attach constraints to grammars to generate more-valid inputs, or weight some alternatives more heavily (not discussed today).
\end{changemargin}
\end{frame}

\usebackgroundtemplate{\tikz\node[opacity=0.2]{\includegraphics[width=\paperwidth]{L09/20231126_224046664_seed_passionflowers_v1.jpg}};}
\begin{frame}
  \frametitle{Grammars \& Mutation Seeds}
  \Large
\begin{changemargin}{2em}
  So far: only produce syntactically valid inputs.\\[1em]
  What about \emph{invalid} inputs?\\[1em]
  One answer: \alert{mutation}.\\[1em]
  Our \texttt{MutationFuzzer} accepts seeds to start from.
\end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Generating CGI strings}
  \Large
\begin{python}
number_of_seeds = 10
seeds = [
    simple_grammar_fuzzer(
        grammar=URL_GRAMMAR,
        max_nonterminals=10) for i in range(number_of_seeds)]
seeds
m = MutationFuzzer(seeds)
[m.fuzz() for i in range(20)]
\end{python}
\begin{changemargin}{2em}
  Use the grammar fuzzer to produce seeds,\\
  then the mutation fuzzer to mutate them.
\end{changemargin}
\end{frame}

\usebackgroundtemplate{}

\begin{frame}[fragile]
  \frametitle{EBNF}
  \begin{changemargin}{2em}
    Extended Backus-Naur form; is syntactic sugar:
    \begin{itemize}
\item \brac{symbol}?: \brac{symbol} can occur 0 or 1 times;
\item \brac{symbol}+: \brac{symbol} can occur 1 or more times;
\item \brac{symbol}*: \brac{symbol} can occur 0 or more times;
\item parentheses can be used with these shortcuts, e.g. (\brac{s1}\brac{s2})+
    \end{itemize}
~\\
    Instead of
\begin{python}
  "<identifier>": ["<idchar>", "<identifier><idchar>"],
\end{python}
just write
\begin{python}
  "<identifier>": ["<idchar>+"],
\end{python}
Function \texttt{convert\_ebnf\_grammar()} (in \texttt{code/L09/ebnf.py}) translates EBNF to BNF.
    
\end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Opts (for future expansion)}
  \begin{changemargin}{2em}
    \Large
\begin{python}
"<expr>":
        [("<term> + <expr>", opts(min_depth=10)),
         ("<term> - <expr>", opts(max_depth=2)),
          "<term>"]
\end{python}
~\\
and there are functions like \texttt{opts()}, \texttt{exp\_string()}, \texttt{exp\_opt()}, \texttt{exp\_opts()},
\texttt{set\_opts()} in \texttt{code/L09/opts.py}.
\end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Grammar Utilities}
  \Large
  found in \texttt{code/L09/grammars.py}:
  \begin{changemargin}{2em}
    \texttt{trim\_grammar()}: remove unneeded expansions;\\[1em]
    \texttt{is\_valid\_grammar()}: validity checks,\\ e.g. no unreachable symbols, etc
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Applications of Grammars in Testing}
  \large
  \begin{changemargin}{2em}
    \begin{itemize}
    \item Earliest known: Burkhardt, 1967: ``Generating test programs from syntax.''
    \item CSmith: grammar-based fuzzing; they work hard to only generate valid C programs;
      pseudo-oracle comparing GCC and LLVM.
    \item EMI: fuzz dead code, observe mis-compilations.
    \item LangFuzz: grammar-based fuzzing on test suites.
    \item Grammarinator: open-source grammar fuzzer in Python.
    \item Domato: fuzzes Document Object Model inputs.
    \end{itemize}

  \end{changemargin}
\end{frame}

\usebackgroundtemplate{\tikz\node[opacity=0.2]{\includegraphics[width=\paperwidth]{L09/04643_leading_tree_v1.jpg}};}
\part{Efficient Grammar Fuzzing}
\begin{frame}
  \partpage
\end{frame}

\begin{frame}[fragile]
  \Large
  \begin{changemargin}{2em}
    Strings\ldots really?\\[1em]
    Easier to specify grammars, sure, but\ldots
  \end{changemargin}
\end{frame}

\usebackgroundtemplate{}

\begin{frame}[fragile]
  \frametitle{A Simple Problem}
  \Large
  \begin{changemargin}{2em}
\begin{python}
expr_grammar = convert_ebnf_grammar(EXPR_EBNF_GRAMMAR)
with ExpectTimeout(1):
  simple_grammar_fuzzer(grammar=expr_grammar, max_nonterminals=3)
\end{python}
does indeed raise a \texttt{TimeoutError}.\\[1em]

(see: \texttt{L09/simple\_grammar\_fuzzer\_problem.py})
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{(((}
\begin{verbatim}
(((((((((((((((((((((((((((((((((((((((((((((((((((((((
(((((((((((((((((((((((((((((((((((((((((((((((((((((((
(((((((((((((((((((((((((((((((((((((((((((((((((((((((
(((((((((((((((((((((((((((((((((((((((((((((((((((((((
(((((((((((((((((((((((((((((((((((((((((((((((((((((((
(((((((((((((((((((((((((((((((((((((((((((((((<factor>
)))))))))))))))))))))))))))))))))))))))))))))))))))))))
)))))))))))))))))))))))))))))))))))))))))))))))))))))))
)))))))))))))))))))))))))))))))))))) + ((((((((((((((((
(((((((((((((((((((((((((((((((((((((((((((((((((((((((
(((((((((((((((((((((((((((((((((((((((((((((((((((((((
(((((((((((((((((((((((((((((((((((((((((((((((((((((((
(((((((((Traceback (most recent call last):
  File "/home/plam/courses/stqam-2026-working-notes/notes/code/L09/simple_grammar_fuzzer_problem.py", line 14, in main
    simple_grammar_fuzzer(grammar=expr_grammar,
         max_nonterminals=3, log=True)
\end{verbatim}
\end{frame}

\begin{frame}[fragile]
  \frametitle{))) Why?}

  \Large
  \begin{changemargin}{2em}
Rule for \brac{factor}:
  \end{changemargin}
\begin{python}
  '<factor>':
    ['<sign-1><factor>', '(<expr>)', '<integer><symbol-1>']
\end{python}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Termination for Simple Grammar Fuzzer}

  \Large
  \begin{changemargin}{1em}
    Let's look at this more closely:
  \end{changemargin}
  \begin{python}
    if len(nonterminals(new_term)) < max_nonterminals:
        term = new_term
        expansion_trials = 0
    else:
        expansion_trials += 1
        if expansion_trials >= max_expansion_trials:
            raise ExpansionError("Cannot expand " + repr(term))

  return term
  \end{python}
  If too many nonterminals after substitution:\\
  \qquad give up on generated string, re-choose.
\end{frame}

\begin{frame}[fragile]
  \frametitle{\texttt{simple\_grammar\_fuzzer} fails}

  \Large
  \begin{changemargin}{2em}
\texttt{simple\_grammar\_fuzzer()} throws away generated
strings with $> 3$ nonterminals.\\[1em]

  \end{changemargin}
\begin{python}
  '<factor>':
    ['<sign-1><factor>', '(<expr>)', '<integer><symbol-1>']
\end{python}

  \begin{changemargin}{2em}
  So, only allowed alternative for \brac{factor} is
\texttt{'(\brac{expr})'}\ldots\\[1em]

\ldots other alternatives add a non-terminal,
so the fuzzer won't.
  \end{changemargin}
\end{frame}

\usebackgroundtemplate{\tikz\node[opacity=0.1]{\includegraphics[width=\paperwidth]{L09/20251209_051044707_cessna_caravan_instruments.jpg}};}

\begin{frame}[fragile]
  \frametitle{Not enough control surfaces}

  \Large
  \begin{changemargin}{2em}
    Any grammar-based approach can create arbitrarily long strings.\\[1em]
    But \texttt{simple\_grammar\_fuzzer()} is too depth-first; we want more breadth.\\[1em]
    The \texttt{max\_nonterminals} control is too coarse.\\[1em]
  \end{changemargin}
\end{frame}
\usebackgroundtemplate{}

\begin{frame}[fragile]
  \frametitle{Too slow}

  \Large
  \begin{changemargin}{2em}
    Also, we don't want to manipulate strings.
  \end{changemargin}
  \begin{center}
    \includegraphics[width=.8\textwidth]{L09/slow_generation.png}
  \end{center}
\end{frame}

\usebackgroundtemplate{\tikz\node[opacity=0.4]{\includegraphics[width=\paperwidth]{L09/20251209_051044707_cessna_caravan_instruments.jpg}};}

\begin{frame}[fragile]
 \hspace*{2em}
  {\Huge \color{blue} {\bf Better controls?}}
\end{frame}
\usebackgroundtemplate{}

\usebackgroundtemplate{\tikz\node[opacity=0.8]{\includegraphics[width=\paperwidth]{L09/04643_leading_tree_v1.jpg}};}
\begin{frame}[fragile]
 \hspace*{2em}
  {\Huge \color{blue} {\bf Trees?}}
\end{frame}
\usebackgroundtemplate{}

\begin{frame}[fragile]
  \frametitle{Derivation Trees!}

\begin{center}
\begin{tikzpicture}[node distance=1.3cm]
  \node[bt,text width=2cm] (s)               {\brac{start}};
  \node[bt] (e0) [below of=s] {\brac{expr}};
  \node[bt,text width=1cm,fill=green!20] (+) [below of=e0] {+};
  \node[bt] (t) [left of=+,xshift=-1cm] {\brac{term}};
  \node[bt] (e1) [right of=+,xshift=1cm] {\brac{expr}};

  \path[->] (s) edge node {} (e0);
  \path[->] (e0) edge node {} (t);
  \path[->] (e0) edge node {} (+);
  \path[->] (e0) edge node {} (e1);
\end{tikzpicture}
\end{center}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Starting at the start}

\begin{center}
\begin{tikzpicture}[node distance=1.3cm]
  \node[bt,text width=2cm] (s)               {\brac{start}};
\end{tikzpicture}
\end{center}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Derivation: \brac{start} $\rightarrow$ \brac{expr}}

\begin{center}
\begin{tikzpicture}[node distance=1.3cm]
  \node[bt,text width=2cm] (s)               {\brac{start}};
  \node[bt] (e0) [below of=s] {\brac{expr}};
  \path[->] (s) edge node {} (e0);
\end{tikzpicture}
\end{center}
\begin{changemargin}{2cm}
Search for nonterminal $S$ without children;\\
here, \brac{start}. Replace with its child \brac{expr}.
\end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Derivation: \brac{expr} $\rightarrow \brac{term} + \brac{expr}$}

\begin{center}
\begin{tikzpicture}[node distance=1.3cm]
  \node[bt,text width=2cm] (s)               {\brac{start}};
  \node[bt] (e0) [below of=s] {\brac{expr}};
  \node[bt,text width=1cm,fill=green!20] (+) [below of=e0] {+};
  \node[bt] (t) [left of=+,xshift=-1cm] {\brac{term}};
  \node[bt] (e1) [right of=+,xshift=1cm] {\brac{expr}};

  \path[->] (s) edge node {} (e0);
  \path[->] (e0) edge node {} (t);
  \path[->] (e0) edge node {} (+);
  \path[->] (e0) edge node {} (e1);
\end{tikzpicture}
\end{center}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Down to terminals}

  \begin{center}
\scalebox{0.8}{
\begin{tikzpicture}[node distance=1.3cm]
  \node[bt,text width=2cm] (s)               {\brac{start}};
  \node[bt] (e0) [below of=s] {\brac{expr}};
  \node[bt,text width=1cm,fill=green!20] (+) [below of=e0] {+};
  \node[bt] (t0) [left of=+,xshift=-1cm] {\brac{term}};
  \node[bt,text width=2cm] (f0) [below of=t0] {\brac{factor}};
  \node[bt,text width=2.5cm] (i0) [below of=f0] {\brac{integer}};
  \node[bt,text width=2.5cm] (d0) [below of=i0] {\brac{digit}};
  \node[bt,fill=green!20] (cd0) [below of=d0] {\brac{2}};
  \node[bt] (e1) [right of=+,xshift=1cm] {\brac{expr}};
  \node[bt] (t1) [below of=e1] {\brac{term}};
  \node[bt,text width=2cm] (f1) [below of=t1] {\brac{factor}};
  \node[bt,text width=2.5cm] (i1) [below of=f1] {\brac{integer}};
  \node[bt,text width=2.5cm] (d1) [below of=i1] {\brac{digit}};
  \node[bt,fill=green!20] (cd1) [below of=d1] {\brac{3}};

  \path[->] (s) edge node {} (e0);
  \path[->] (e0) edge node {} (t0);
  \path[->] (t0) edge node {} (f0);
  \path[->] (f0) edge node {} (i0);
  \path[->] (i0) edge node {} (d0);
  \path[->] (d0) edge node {} (cd0);
  \path[->] (e0) edge node {} (+);
  \path[->] (e0) edge node {} (e1);
  \path[->] (e1) edge node {} (t1);
  \path[->] (t1) edge node {} (f1);
  \path[->] (f1) edge node {} (i1);
  \path[->] (i1) edge node {} (d1);
  \path[->] (d1) edge node {} (cd1);
\end{tikzpicture}
}
\end{center}
\end{frame}

\usebackgroundtemplate{\tikz\node[opacity=0.2]{\includegraphics[width=\paperwidth]{L09/04643_leading_tree_v1.jpg}};}
\begin{frame}[fragile]
  \Huge
\begin{center}
  Derivation Trees in Python
\end{center}
\end{frame}

\usebackgroundtemplate{}

\begin{frame}[fragile]
  \Large
  \frametitle{Representing derivation trees}
  \begin{changemargin}{2cm}
  \begin{python}
    (SYMBOL_NAME, CHILDREN)
  \end{python}
  ~\\
  SYMBOL\_NAME: e.g. \brac{start}, \texttt{+}\\
  (again, nonterminals in \brac{brackets})\\[1em]
  CHILDREN: the subtree at that node\\[1em]
  \begin{python}
DerivationTree = Tuple[str, Optional[List[Any]]]
  \end{python}
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \Large
  \frametitle{Example Derivation Tree}
  \begin{changemargin}{2cm}
\begin{python}
derivation_tree: DerivationTree = ("<start>",
                   [("<expr>",
                     [("<expr>", None),
                      (" + ", []),
                         ("<term>", None)]
                     )])
\end{python}
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \Large
  \frametitle{Allowed CHILDREN}
  \begin{changemargin}{2cm}
    \begin{itemize}
      \item the subtree
      \item None: this is a nonterminal still to be expanded
      \item {} []: this node is a terminal
    \end{itemize}
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \Large
  \frametitle{GrammarFuzzer Implementation}
  \begin{changemargin}{2cm}
\begin{python}
class GrammarFuzzer(Fuzzer):
"""Produce strings from grammars efficiently,
       using derivation trees."""

  def __init__(self,
               grammar: Grammar,
               start_symbol: str = START_SYMBOL,
               min_nonterminals: int = 0,
               max_nonterminals: int = 10,
               disp: bool = False,
               log: Union[bool, int] = False)
               -> None:
      # ...
\end{python}
For now, only use \texttt{grammar} and \texttt{start\_symbol}.
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \Large
  \frametitle{Partial check for grammar validity}
\begin{python}
      def check_grammar(self) -> None:
        assert self.start_symbol in self.grammar
        # recall: e.g. every nonterminal is reachable etc
        assert is_valid_grammar(
            self.grammar,
            start_symbol=self.start_symbol,
            supported_opts=self.supported_opts())
\end{python}

\end{frame}

\begin{frame}[fragile]
  \Large
  \frametitle{Tree manipulations}
  \begin{changemargin}{1cm}
    Better than string manipulations.\\[1em]
    We want to expand nonterminals (selectively).\\[1em]

    Alternatives in grammars still expressed as strings, e.g.
\begin{python}
"<expr>":
        [("<term> + <expr>"),
         ("<term> - <expr>"),
          "<term>"]
\end{python}
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \Large
  \frametitle{Strings to trees}
  \begin{changemargin}{1cm}
\begin{python}
def expansion_to_children(expansion: Expansion) ->
           List[DerivationTree]:
  expansion = exp_string(expansion)
  assert isinstance(expansion, str)

  if expansion == "":
      return [("", [])]

  strings = re.split(RE_NONTERMINAL, expansion)
  return [(s, None) if is_nonterminal(s) else (s, [])
          for s in strings if len(s) > 0]

>>> expansion_to_children([("<term> + <expr>")])
[('<term>', None), (' + ', []), ('<expr>', None)]
\end{python}
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Expanding a node}

  \begin{center}
\begin{tikzpicture}[node distance=1.3cm]
  \node[bt] (e0) [below of=s] {\brac{expr}};
  \node[bt,text width=1cm,fill=green!20] (+) [below of=e0] {+};
  \node[bt] (t) [left of=+,xshift=-1cm] {\brac{term}};
  \node[bt] (e1) [right of=+,xshift=1cm] {\brac{expr}};

  \path[->] (e0) edge node {} (t);
  \path[->] (e0) edge node {} (+);
  \path[->] (e0) edge node {} (e1);
\end{tikzpicture}
  \end{center}
  \begin{changemargin}{2cm}
    Key operation: expand nonterminal into one of its alternatives;
    here we have chosen +, but could also be - or a term.\\[1em]
    We replaced \brac{expr} with e.g. $\brac{term} + \brac{expr}$.
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Randomly choosing an alternative}
\large
\begin{changemargin}{1cm}
  Same choice strategy as \texttt{simple\_grammar\_fuzzer}.
\end{changemargin}
\begin{python}
def choose_node_expansion(self, node: DerivationTree,
     children_alternatives: List[List[DerivationTree]]) -> int:
  return random.randrange(0, len(children_alternatives))
\end{python}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Random expansion implementation}
  \Large
\begin{changemargin}{1cm}
  For a subtree with non-expanded non-terminal at root
  (\texttt{children} == \texttt{None}):
  \begin{itemize}
\item  expand non-terminal into one of its alternatives (randomly chosen),
\item  return the tree.
  \end{itemize}
\end{changemargin}

\begin{python}
def expand_node_randomly(self, node: DerivationTree) -> DerivationTree:
  (symbol, children) = node
  assert children is None

  # Fetch & parse possible expansions from grammar...
  expansions = self.grammar[symbol]
  children_alternatives: List[List[DerivationTree]] = [
      self.expansion_to_children(expansion) for expansion in expansions
  ]
\end{python}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Random expansion implementation 2}
  \large
\begin{python}
  # ... and select a random expansion
  index = self.choose_node_expansion(node, children_alternatives)
  chosen_children = children_alternatives[index]

  # Return with new children
  return (symbol, chosen_children)
\end{python}

\begin{changemargin}{2cm}
\texttt{expand\_node\_*} return a fresh \texttt{DerivationTree},
consistent with functional programming style.\\[1em]

Randomly is for now our only strategy;
we will later redefine \texttt{expand\_node} 
to use other strategies.
\end{changemargin}
\begin{python}
    def expand_node(self, node: DerivationTree) -> DerivationTree:
        return self.expand_node_randomly(node)
\end{python}
\end{frame}

\begin{frame}[fragile]
  \frametitle{\texttt{expand\_node} in action}

\begin{python}
>>> f = GrammarFuzzer(EXPR_GRAMMAR, log=True)

>>> print("Before expand_node_randomly():")
>>> expr_tree = ("<integer>", None)
>>> print (expr_tree)
('<integer>', None)

>>> expr_tree = f.expand_node_randomly(expr_tree)
>>> print("After expand_node_randomly():")
>>> print (expr_tree)
('<integer>', [('<digit>', None), ('<integer>', None)])
\end{python}
or also possible:
\begin{python}
>>> print (expr_tree)
('<integer>', [('<digit>', None)])
\end{python}

\begin{changemargin}{2cm}
\texttt{expand\_node\_*} return a fresh \texttt{DerivationTree},
consistent with functional programming style.\\[1em]

Randomly is for now our only strategy;
we will later redefine \texttt{expand\_node} 
to use other strategies.
\end{changemargin}
\begin{python}
    def expand_node(self, node: DerivationTree) -> DerivationTree:
        return self.expand_node_randomly(node)
\end{python}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Picking a node to expand}

  \Large
  \begin{changemargin}{1cm}
    \texttt{expand\_node()}: return expanded current node.\\[1em]
    \texttt{expand\_tree\_once()}: modify the tree; pick some node and call \texttt{expand\_node()} on that.\\[1em]
    Specifically: if root is unexpanded, expand that.\\
    Otherwise, find a random descendant and expand that.\\[1em]
    NB: uses the current definition of \texttt{self.expand\_node}, which can change.
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{\texttt{expand\_tree\_once()} example}
  \begin{python}
>>> f.expand_node = f.expand_node_randomly
>>> derivation_tree = ("<start>",
                        [("<expr>",
                          [("<expr>", None), (" + ", []),
                           ("<term>", None)])])
>>> print (derivation_tree)
('<start>', [('<expr>', [('<expr>', None), (' + ', []), 
             ('<term>', None)])])
>>> f.expand_tree_once(derivation_tree)
Expanding <term> randomly
>>> f.expand_tree_once(derivation_tree)
Expanding <expr> randomly
>>> print (derivation_tree)
('<start>', [('<expr>', [('<expr>', [('<term>', None), 
   (' + ', []), ('<expr>', None)]), (' + ', []),
    ('<term>', [('<factor>', None), (' / ', []),
    ('<term>', None)])])])
\end{python}
\end{frame}

\usebackgroundtemplate{\tikz\node[opacity=0.2]{\includegraphics[width=\paperwidth]{L09/20230820_215122777_closed.jpg}};}
\begin{frame}[fragile]
  ~\\[1em]
 \hspace*{2em}
         {\Huge Idea 1: Closing the Tree}
         \\[1em]
         \hspace*{2em} {\large credit: Sean Luke, 2000.}
\end{frame}
\usebackgroundtemplate{}

\begin{frame}[fragile]
  \frametitle{How to close the tree?}

  \Large
  \begin{changemargin}{1cm}
    Once our tree is big enough,\\
    choose expansions that increase tree size least.\\[1em]
    e.g. \brac{factor} could be\\
    \qquad $\brac{integer}(.\brac{integer})?$,\\
    which could be \brac{integer}, \\
    which could be a single \brac{digit}.\\[1em]
    (Other alternatives are higher-cost).
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Choosing the minimum-cost expansion}

  \Large
  \begin{changemargin}{1cm}
    Traverse the tree \& sum the minima.
  \end{changemargin}
\begin{python}
def symbol_cost(self, symbol: str, seen: Set[str] = set()) -> Union[int, float]:
    expansions = self.grammar[symbol]
    return min(self.expansion_cost(e, seen | {symbol}) for e in expansions)

def expansion_cost(self, expansion: Expansion,
                   seen: Set[str] = set()) -> Union[int, float]:
    symbols = nonterminals(expansion)
    if len(symbols) == 0:
        return 1  

    if any(s in seen for s in symbols):
        return float('inf')

    return sum(self.symbol_cost(s, seen) for s in symbols) + 1
\end{python}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Minimum-cost expansion commentary}

  \Large
\begin{python}
def symbol_cost(self, symbol: str, seen: Set[str] = set()) -> Union[int, float]:
\end{python}
  \begin{changemargin}{1cm}
    is the minimum cost of the children of \texttt{symbol}.
  \end{changemargin}
~\\
\begin{python}
def expansion_cost(self, expansion: Expansion,
        seen: Set[str] = set()) -> Union[int, float]:
\end{python}
\begin{changemargin}{1cm}
  if \texttt{expansion} has no nonterminals, return 1;\\
  if any nonterminal in \texttt{expansion} is in \texttt{seen}, return inf;\\
  else, return 1 + $\sum$ \texttt{symbol\_cost}(children).
\end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Minimum-cost expansion examples}

  \Large
\begin{changemargin}{1cm}
\begin{python}
>>> f = GrammarFuzzer(EXPR_GRAMMAR)
>>> f.symbol_cost("<digit>")
1
>>> f.symbol_cost("<expr>")
5
\end{python}
\end{changemargin}
\begin{changemargin}{2cm}
  The min cost of \brac{expr} is 5, through \brac{term}, \brac{factor}, \brac{integer}, \brac{digit}, and 1.
\end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Beyond random: parametrizing by algorithm}

  \Large
\begin{changemargin}{1cm}
\begin{python}
def expand_node_by_cost(self, node: DerivationTree, 
                       choose: Callable = min)
    -> DerivationTree:
\end{python}
\end{changemargin}

\begin{changemargin}{1.5cm}
  This functional-style method:
  \begin{itemize}
  \item collects min cost of alternatives;
  \item asks \texttt{choose} to choose a desired cost;
  \item collects all alternatives with chosen cost;
  \item uses \texttt{choose\_node\_expansion()} to choose an alternative\\
    (default: random);
  \item returns chosen alternative.
  \end{itemize}
\end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Using \texttt{min} as choice algorithm}

  \Large
\begin{changemargin}{1cm}
\begin{python}
def expand_node_min_cost(self, node: DerivationTree) -> DerivationTree:
    return self.expand_node_by_cost(node, min)
\end{python}
and using it:
\begin{python}
>>> f.expand_node = f.expand_node_min_cost
>>> while f.any_possible_expansions(derivation_tree):
     derivation_tree = f.expand_tree_once(derivation_tree)
Expanding <term> at minimum cost
Expanding <factor> at minimum cost
Expanding <term> at minimum cost
... etc ...
>>> print (all_terminals(derivation_tree))
5 + 5 + 6 / 1
\end{python}
\end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Why closing works}
  \Large
  \begin{changemargin}{2cm}
    \begin{itemize}
    \item \texttt{expand\_node\_min\_cost()} does not increase the number of symbols,
    \item so all open expansions are eventually closed.
    \end{itemize}~\\
    I think this is a property of the grammar as well as the implementation.
  \end{changemargin}
\end{frame}

\usebackgroundtemplate{\tikz\node[opacity=0.4]{\includegraphics[width=\paperwidth]{L09/6941_balloons.jpg}};}
\begin{frame}[fragile]
  ~\\[1em]
 \hspace*{2em}
         {\Huge Idea 1.5: Node Inflation}
         \\[1em]
         \hspace*{2em} {\large also from Sean Luke, 2000.}
\end{frame}
\usebackgroundtemplate{}

\begin{frame}[fragile]
  \frametitle{Node Inflation}

  \Large
  \begin{changemargin}{2cm}
    Want to make sure that our inputs are big enough.\\[1em]
    Instead of min-cost expansion, find the \alert{max} cost:
  \end{changemargin}

  \begin{python}
def expand_node_max_cost(self, node: DerivationTree) -> DerivationTree:
    return self.expand_node_by_cost(node, max)
  \end{python}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Experiencing Inflation}

  \Large
  \begin{changemargin}{2cm}
and we can run it:
  \end{changemargin}

  \begin{python}
>>> derivation_tree = ("<start>",
                [("<expr>", [("<expr>", None),
                   (" + ", []),
                 ("<term>", None)]
               )])
>>> f = GrammarFuzzer(EXPR_GRAMMAR, log=True)
>>> f.expand_node = f.expand_node_max_cost

>>> # do this a number of times
>>> if f.any_possible_expansions(derivation_tree):
       derivation_tree = f.expand_tree_once(derivation_tree)
  ...
>>> print (all_terminals(derivation_tree))
<expr> + +<factor> / <factor> / <term>
\end{python}
\end{frame}

\usebackgroundtemplate{\tikz\node[opacity=0.2]{\includegraphics[width=\paperwidth]{L09/PXL_20250620_082126897.jpg}};}
\begin{frame}[fragile]
  ~\\[1em]
 \hspace*{2em}
         {\Huge Combining Ideas: \\ \qquad max, random, min}
\end{frame}
\usebackgroundtemplate{}

\begin{frame}[fragile]
  \frametitle{Applying a strategy}

  \Large
  \begin{python}
def expand_tree_with_strategy(self, tree: DerivationTree,
                              expand_node_method: Callable,
                              limit: Optional[int] = None):
    """Expand tree using `expand_node_method`
    until number of possible expansions reaches `limit`."""
    self.expand_node = expand_node_method
    while ((limit is None
            or self.possible_expansions(tree) < limit)
           and self.any_possible_expansions(tree)):
        tree = self.expand_tree_once(tree)
    return tree
\end{python}
\end{frame}

\begin{frame}[fragile]
  \frametitle{max, then random, then min}

  \Large
  \begin{python}
def expand_tree(self, tree: DerivationTree) -> DerivationTree:
    """Expand `tree` in a three-phase strategy until all expansions are complete."""
    tree = self.expand_tree_with_strategy(
        tree, self.expand_node_max_cost, self.min_nonterminals)
    tree = self.expand_tree_with_strategy(
        tree, self.expand_node_randomly, self.max_nonterminals)
    tree = self.expand_tree_with_strategy(
        tree, self.expand_node_min_cost)

    assert self.possible_expansions(tree) == 0
    return tree
  \end{python}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Creating a tree}

  \begin{python}
>>> derivation_tree = ("<start>",
                [("<expr>", [("<expr>", None),
                   (" + ", []),
                 ("<term>", None)]
               )])
>>> f = GrammarFuzzer(
         EXPR_GRAMMAR,
         min_nonterminals=3,
         max_nonterminals=5,
         log=True)
>>> f.expand_tree(derivation_tree)
... (max x1, randomly x2, minimum x20) ...
Tree: 3 * 5 - 1 + 8 * 9
\end{python}
\end{frame}

\usebackgroundtemplate{\tikz\node[opacity=0.3]{\includegraphics[width=\paperwidth]{L03/09038_lots_of_moss_v1.JPG}};}
\begin{frame}[fragile]
  ~\\[1em]
 \hspace*{2em}
         {\Huge Just a fuzzer}
\end{frame}
\usebackgroundtemplate{}

\begin{frame}[fragile]
  \frametitle{Abstract everything}
  \begin{python}
class GrammarFuzzer(Fuzzer):
    def fuzz_tree(self) -> DerivationTree:
        """Produce a derivation tree from the grammar."""
        tree = self.init_tree()

        # Expand all nonterminals
        tree = self.expand_tree(tree)
        return tree

    def fuzz(self) -> str:
        """Produce a string from the grammar."""
        self.derivation_tree = self.fuzz_tree()
        return all_terminals(self.derivation_tree)  
  \end{python}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Easy Interface}

\begin{changemargin}{1cm}
  Sensible defaults make it easy to use:
\end{changemargin}
\begin{python}
>>> f = GrammarFuzzer(EXPR_GRAMMAR)
>>> print (f.fuzz())
+1 / 6
>>> print (f.fuzz())
6.4 * (3 * 0 / 3) - -91 * 5 / 8 * 8
>>> g = GrammarFuzzer(URL_GRAMMAR)
>>> print (g.fuzz())
ftps://fuzzingbook.com
>>> h = GrammarFuzzer(CGI_GRAMMAR)
>>> print (h.fuzz())
%d2
\end{python}
\begin{changemargin}{1cm}
  Might also look at the derivation tree returned from \texttt{fuzz\_tree()}.
\end{changemargin}
\begin{python}
>>> print (h.fuzz_tree())
('<start>', [('<string>', [('<letter>', [('<other>', [('c', [])])])])])
\end{python}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Concluding Remarks: Efficient Grammar Fuzzing}

  \Large
\begin{changemargin}{2cm}
  \texttt{GrammarFuzzer} much faster than \texttt{simple\_grammar\_fuzzer} and produces smaller inputs.\\[1em]
  Better control over grammar production (min, max nonterminals.)\\[1em]
  Three phases: max, random, min.\\[1em]
\end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Inefficient Grammar Fuzzing Times (EXPR\_GRAMMAR)}

  \Large
  \begin{center}
    \includegraphics[width=.8\textwidth]{L09/slow_generation.png}
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Efficient Grammar Fuzzing Times (EXPR\_GRAMMAR)}

  \Large
  \begin{center}
    \includegraphics[width=.8\textwidth]{L09/grammarfuzzer_times.png}
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{And it works on EBNF, too}

\begin{python}
>>> expr_grammar = convert_ebnf_grammar(EXPR_EBNF_GRAMMAR)
>>> f = GrammarFuzzer(expr_grammar, max_nonterminals=10)
>>> print (f.fuzz())
97.01 * 5 * 7 - 8 * 9 - (9 + 0)
\end{python}

\end{frame}

\end{document}
