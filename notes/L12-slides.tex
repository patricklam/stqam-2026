\documentclass{beamer}

\usetheme{Boadilla}

\usepackage{times}
\usefonttheme{structurebold}
\usepackage{listings}

\usepackage{pgf}
\usepackage{tikz}
\usepackage{alltt}
\usepackage[normalem]{ulem}
\usetikzlibrary{arrows}
\usetikzlibrary{automata}
\usetikzlibrary{shapes}
\usepackage{amsmath,amssymb}
\usepackage{rotating}
\usepackage{ulem}
\usepackage{pythonhighlight}

\usetikzlibrary{arrows,automata,shapes}
\tikzstyle{block} = [rectangle, draw, fill=blue!20, 
    text width=5em, text centered, rounded corners, minimum height=2em]
\tikzstyle{bt} = [rectangle, draw, fill=blue!20, 
    text width=4em, text centered, rounded corners, minimum height=2em]

\lstdefinelanguage{FSharp}%
{morekeywords={let, new, match, with, rec, open, module, namespace, type, of, member, % 
and, for, while, true, false, in, do, begin, end, fun, function, return, yield, try, %
mutable, if, then, else, cloud, async, static, use, abstract, interface, inherit, finally },
  otherkeywords={ let!, return!, do!, yield!, use!, var, from, select, where, order, by },
  keywordstyle=\color{blue},
  sensitive=true,
  basicstyle=\ttfamily,
	breaklines=true,
  xleftmargin=\parindent,
  aboveskip=\bigskipamount,
	tabsize=4,
  morecomment=[l][\color{olive}]{///},
  morecomment=[l][\color{olive}]{//},
  morecomment=[s][\color{olive}]{{(*}{*)}},
  morestring=[b]",
  showstringspaces=false,
  literate={`}{\`}1,
  stringstyle=\color{redstrings},
}

\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, 
do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]''
}

%\setbeamercovered{dynamic}
\setbeamertemplate{footline}[page number]{}
\setbeamertemplate{navigation symbols}{}
\usefonttheme{structurebold}

\title{Software Testing, Quality Assurance \& Maintenance---Lecture 12}
\author{Patrick Lam\\University of Waterloo}
\date{February 13, 2026}

\colorlet{redshaded}{red!25!bg}
\colorlet{shaded}{black!25!bg}
\colorlet{shadedshaded}{black!10!bg}
\colorlet{blackshaded}{black!40!bg}

\colorlet{darkred}{red!80!black}
\colorlet{darkblue}{blue!80!black}
\colorlet{darkgreen}{green!80!black}

\newcommand{\rot}[1]{\rotatebox{90}{\mbox{#1}}}
\newcommand{\gray}[1]{\mbox{#1}}

\newenvironment{changemargin}[1]{% 
  \begin{list}{}{% 
    \setlength{\topsep}{0pt}% 
    \setlength{\leftmargin}{#1}% 
    \setlength{\rightmargin}{1em}
    \setlength{\listparindent}{\parindent}% 
    \setlength{\itemindent}{\parindent}% 
    \setlength{\parsep}{\parskip}% 
  }% 
  \item[]}{\end{list}}

\newcommand{\brac}[1]{\texttt{\textless #1\textgreater}}


\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\part{Property-Based Testing}
\begin{frame}
  \partpage
\end{frame}

\begin{frame}
  \frametitle{Begging the Question\ldots}
  \Huge
  \begin{changemargin}{1cm}
Property-based testing is \ldots testing using properties?
  \end{changemargin}
\end{frame}

\begin{frame}
  \frametitle{Go on\ldots}
  \Large
  \begin{changemargin}{2cm}
    What kind of properties?
    \begin{itemize}
    \item specify the ``shape'' of ``interesting'' inputs;
    \item properties of the system's abstractions;
    \end{itemize}
    Or: it triggers failures that could not have been revealed by direct fuzzing.\\[1em]
    Or: properties are things that are true for any correct implementation.
  \end{changemargin}
\end{frame}


\usebackgroundtemplate{\tikz\node[opacity=0.1]{\includegraphics[width=\paperwidth]{L12/01135_paradise_shelducks.jpg}};}
\begin{frame}
  \frametitle{Does it quack like a duck?}
  \Large
  \begin{changemargin}{2cm}
    In property-based testing, we write test cases that verify (ideally deep) system properties.\\[1em]
    Property-based tests usually use a fuzzer to generate inputs.\\[1em]
    Reminiscent of metamorphic testing.
  \end{changemargin}
\end{frame}
\usebackgroundtemplate{}

\begin{frame}[fragile]
  \frametitle{\texttt{map}}
  \Large
  \begin{changemargin}{1cm}
  \begin{python}
    def map(fn, xs):
      ys = []
      for x in xs:
        ys.append(fn(x))
      return ys
  \end{python}

  As we'd expect, \texttt{list(map(lambda x: x+1, [3, 4]))} yields \texttt{[4, 5]}.
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{An example property test}
  \Large
    \begin{changemargin}{2cm}
      Python Hypothesis library:
  \begin{python}
@given(st.lists(st.integers()))
def map_identity_yields_self(xs):
    id = lambda x: x
    assert list(map(id, xs)) == xs
  \end{python}
\texttt{map}ping the identity function $\lambda x.~x$ on list $\ell$
yields the same list $\ell$.

  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Note: not concrete}
  \begin{changemargin}{2cm}
    \Large
  \begin{python}
@given(st.lists(st.integers()))
def map_identity_yields_self(xs):
    id = lambda x: x
    assert list(map(id, xs)) == xs
  \end{python}
  Hypothesis generates inputs (lists of integers) using fuzzing-like techniques.\\[1em]
  It calls this function repeatedly with generated inputs.\\[1em]
  Purpose: ensure that assertions hold.
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{What Hypothesis Does}
  \large
  \begin{changemargin}{1cm}
    Here's some skeleton F\# code:
\begin{lstlisting}[language=FSharp]
let propertyCheck property =
  // property has type: int -> int -> bool
  for _ in [1..100] do
    let x = randInt()
    let y = randInt()
    let result = property x y
    Assert.IsTrue(result)
\end{lstlisting}
    \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Getting diagnostics}
  \begin{changemargin}{2cm}
    \Large
  \begin{python}
@given(st.lists(st.integers()))
@settings(verbosity=Verbosity.verbose)    
def map_identity_yields_self(xs):
    id = lambda x: x
    assert list(map(id, xs)) == xs
  \end{python}
  Otherwise, no news is good news.\\[1em]
  When you do get a failure report, Hypothesis simplifies the report.
    \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{List Examples}
  \Large
  \begin{changemargin}{2cm}
    In the full notes, you'll see a bunch of examples. \\[1em]
    I won't put them on slides,
    but you can find them in \texttt{code/L12/list\_tests.py}.\\[1em]
    \end{changemargin}
\end{frame}

\usebackgroundtemplate{\tikz\node[opacity=0.3]{\includegraphics[width=\paperwidth]{L12/07035_blue_sea_wave_pattern_hope_for_eternal_peace.JPG}};}
\begin{frame}[fragile]
  \frametitle{Patterns for Property-Based Testing}
  \Large
  \begin{changemargin}{2cm}
\begin{quote}
Everyone who sees a property-based testing tool like FsCheck or QuickCheck thinks that it is amazingâ€¦ but when it comes time to start creating your own properties, the universal complaint is: ``What properties should I use? I can't think of any!''
\end{quote}
    
    \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Common Patterns}
  \Large
  \begin{changemargin}{2cm}
\begin{itemize}
\item Different paths, same destination
\item There and back again
\item Some things never change
\item The more things change, the more they stay the same
\item Solve a smaller problem first
\item Hard to prove, easy to verify
\item The test oracle
\end{itemize}
  \end{changemargin}
\end{frame}



\usebackgroundtemplate{}

\begin{frame}[fragile]
  \frametitle{Different paths, same destination}
  \Large
  \begin{changemargin}{2cm}
    Check that doing $X$ then $Y$ gives the same thing as doing $Y$ and then $X$.\\[1em]
    e.g. sort, add 1.
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{There and back again}
  \Large
  \begin{changemargin}{2cm}
    Do $X$ and then its inverse $X^{-1}$.\\[1em]
    e.g. serialize/deserialize.
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Some things never change}
  \Large
  \begin{changemargin}{2cm}
    Is an invariant preserved?\\[1em]
    e.g. collection size/contents
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The more things change, the more they stay the same}
  \Large
  \begin{changemargin}{2cm}
    Idempotence: doing an operation twice is same as doing it once.\\[1em]
    e.g. deduplicating a collection
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Solve a smaller problem first}
  \Large
  \begin{changemargin}{2cm}
    Properties based on structural induction.
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Hard to prove, easy to verify}
  \Large
  \begin{changemargin}{2cm}
    e.g. maze pathfinding vs verification, factorization into primes, string tokenization vs concatenation, literally proof derivation vs verification.
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Test oracle}
  \Large
  \begin{changemargin}{2cm}
Compare with results from an oracle.
  \end{changemargin}
\end{frame}

\part{Commentary}
\begin{frame}
  \partpage
\end{frame}

\begin{frame}[fragile]
  \frametitle{Property testing vs metamorphic testing}
  \Large
  \begin{changemargin}{2cm}
    Pretty similar.\\[1em]
    Properties in property-based testing will often qualify as metamorphic relations.\\[1em]
    In property testing, use framework to generate tests; in metamorphic testing, use the relation to generate more tests.
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Property testing vs fuzzing}
  \Large
  \begin{changemargin}{2cm}
    Property testing uses fuzzing.\\
    Fuzzing benefits from implicit oracles.\\[1em]
    Difference: fuzzing focussed on creating random inputs \& finding crashes (especially security problems).\\
    In fuzzing, system properties are incidental.\\[1em]
    Property-based testing relies on developer to describe interesting inputs.
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Property testing and system design}
  \Large
  \begin{changemargin}{2cm}
    Claim: property testing gives a better understanding of system design \& invariants, as you are designing the system.\\[1em]
    
    Like Test-Driven Development (TDD), but with deeper properties. \\
    TDD: write minimal working code that passes the test cases. \\
    Property testing: write minimal code (the EDFH code), then think of properties that break this code.
  \end{changemargin}
\end{frame}
\end{document}
