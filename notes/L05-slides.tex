\documentclass{beamer}

% TODO: print out https://www.fuzzingbook.org/code/Intro_Testing.py

\usetheme{Boadilla}

%\includeonlyframes{current}

\usepackage{times}
\usefonttheme{structurebold}
\usepackage{listings}
\usepackage[listings]{tcolorbox}

\usepackage{pgf}
\usepackage{tikz}
\usepackage{alltt}
\usepackage[normalem]{ulem}
\usetikzlibrary{arrows}
\usetikzlibrary{automata}
\usetikzlibrary{shapes}
\usetikzlibrary{backgrounds}
\usepackage{amsmath,amssymb}
\usepackage{rotating}
\usepackage{ulem}
\usepackage{pythonhighlight}

\usetikzlibrary{arrows,automata,shapes}
\tikzstyle{block} = [rectangle, draw, fill=blue!20, 
    text width=5em, text centered, rounded corners, minimum height=2em]
\tikzstyle{bt} = [rectangle, draw, fill=blue!20, 
    text width=4em, text centered, rounded corners, minimum height=2em]

\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, 
do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]''
}

%\setbeamercovered{dynamic}
\setbeamertemplate{footline}[page number]{}
\setbeamertemplate{navigation symbols}{}
\usefonttheme{structurebold}

\title{Software Testing, Quality Assurance \& Maintenance---Lecture 5}
\author{Patrick Lam\\University of Waterloo}
\date{January 19, 2026}

\colorlet{redshaded}{red!25!bg}
\colorlet{shaded}{black!25!bg}
\colorlet{shadedshaded}{black!10!bg}
\colorlet{blackshaded}{black!40!bg}

\colorlet{darkred}{red!80!black}
\colorlet{darkblue}{blue!80!black}
\colorlet{darkgreen}{green!80!black}

\newcommand{\rot}[1]{\rotatebox{90}{\mbox{#1}}}
\newcommand{\gray}[1]{\mbox{#1}}

\newenvironment{changemargin}[1]{% 
  \begin{list}{}{% 
    \setlength{\topsep}{0pt}% 
    \setlength{\leftmargin}{#1}% 
    \setlength{\rightmargin}{1em}
    \setlength{\listparindent}{\parindent}% 
    \setlength{\itemindent}{\parindent}% 
    \setlength{\parsep}{\parskip}% 
  }% 
  \item[]}{\end{list}}



\begin{document}

\usebackgroundtemplate{\tikz\node[opacity=0.1]{\includegraphics[width=\paperwidth]{L05/960px-Delphi_Temple_of_Apollo.jpeg}};}
\begin{frame}
  \titlepage
  {\scriptsize
    Background: Temple of Apollo @ Delphi; by Skyring - Own work, CC BY-SA 4.0, \url{https://commons.wikimedia.org/w/index.php?curid=64170779}
    }
\end{frame}

\usebackgroundtemplate{}
\part{The Oracle Problem}
\begin{frame}
  \partpage
  
\end{frame}

\begin{frame}
  \frametitle{What's the right answer?}
  \Huge
  \begin{changemargin}{2em}
    cop-out: ``ask a human''
  \end{changemargin}
\end{frame}

\begin{frame}
  \frametitle{Begging the Question}
  \Large
  \begin{changemargin}{2em}
    Taking the answer the system computes \\ as the right answer.\\[1em]
    (is the basis for regression testing, though)
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Simple example: add}
  \Large
  \begin{changemargin}{2em}
    \begin{lstlisting}[language=Python]
      def add(x, y):
        return x + y
    \end{lstlisting}
    ~\\[1em]
    We all agree about the output of \texttt{add(1,1)}.\\[1em]

    Right?
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{(Almost)}
  \Large
  \begin{changemargin}{2em}
    (What about \texttt{add("3", 5)} in JavaScript?)
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{High school math}
  \Large
  \begin{changemargin}{2em}
    Consider function \texttt{solve\_quadratic()} for
    \[ x^2-2x-4 = 0. \]

    Need to read the function name and remember high school math.\\[2em]

    Also, edge cases: no solutions;\\ \qquad floating-point shenanigans.
  \end{changemargin}
\end{frame}

\begin{frame}
  \frametitle{Human Oracles: source of truth}
  \Large
  \begin{changemargin}{2em}
  Unit level: Mainly use the function name,\\
  plus any function documentation (if it exists).\\[1em]

  More generally: You use your human experience to say what the answer should be.
  \end{changemargin}
\end{frame}

\part{Helping Human Oracles}
\begin{frame}
  \partpage
\end{frame}

\begin{frame}
  \frametitle{Sometimes there is no alternative}
  \Huge
  \begin{changemargin}{2em}
    You may have to \\ ask a human.
  \end{changemargin}
\end{frame}

\begin{frame}
  \frametitle{Basis for judgment}
  \Large
  \begin{changemargin}{2em}
    Does the output meet the system requirements?\\[2em]

    (Eliciting requirements not in scope for this course.)
  \end{changemargin}
\end{frame}

\begin{frame}
  \frametitle{Easy versus hard inputs}
  \Large
  \begin{changemargin}{2em}
    Setting: function \texttt{calculate\_days\_between()}.\\[2em]
    What's the answer for:
    \begin{itemize}
    \item 12/24/2025 and 12/25/2025?
    \end{itemize}~ \\[0em]
    What about
    \begin{itemize}
    \item -5455/23195/-30879 and -5460/24100/-30800?
    \end{itemize}
    Even if we sanitize/declare negative numbers invalid, some
     inputs are still easier to check.
  \end{changemargin}
\end{frame}

\begin{frame}
  \frametitle{Input Profiles}
  \Large
  \begin{changemargin}{2em}
    Generate inputs that fit expected input profiles:\\[2em]
    
    Start with developers' sanity-check inputs \\
    \qquad (like 12/24/2025 and 12/25/2025 etc).\\[2em]

    Also, sanitizing checks inside the code are good places to start.\\[2em]

    Months: valid months, 0, -1, 13.\\[2em]
    
  \end{changemargin}

\end{frame}

\begin{frame}
  \frametitle{Other options}
  \Large
  \begin{changemargin}{2em}
    1. Start from normal inputs, \\
    \hspace*{2em} use genetic algorithms, \\
    \hspace*{2em} or generate from distributions.\\[1em]

    2. Reuse partial inputs, manually modified;\\
    \hspace*{2em} change one thing at a time,\\
    \hspace*{2em} thus, easier to reason about changes in the output.\\[1em]
    \hspace*{2em} e.g. go from 0/1/2010 to 1/1/2010, etc.
    
  \end{changemargin}

\end{frame}

\begin{frame}
  \frametitle{Integers vs strings}
  \large
  \begin{changemargin}{2em}
    Even though some integers aren't very good (e.g. 23195),\\
    it's still easier to create integers than strings,\\
    and easier to create strings than e.g. trees.\\[2em]

    Space of strings is bigger; \\
    space of sensible strings is proportionally smaller.\\[2em]

    Can use random strings as fuzzed inputs,\\
    but also want strings that pass sanity checks.\\[2em]

    Can mine the web for strings, or generate strings using heuristics
    (or LLMs).
        
  \end{changemargin}

\end{frame}

\begin{frame}
  \frametitle{Crowdsourcing inputs}
  \Large
  \begin{changemargin}{2em}
    People have tried to use Mechanical Turk.\\[2em]
    Apparently it's hard to get good results.
  \end{changemargin}
\end{frame}

\usebackgroundtemplate{\begin{tikzpicture}\node[opacity=0.3]{\hspace*{.2\paperwidth} \includegraphics[width=.6\paperwidth, trim=0 0 0 -20em]{L05/02936_mini_churchy_entrance_v1.jpg}};\end{tikzpicture}}
\begin{frame}
  \frametitle{Reducing volume of work for human testers}
  \Large
  \begin{changemargin}{2em}
    People always hope for test suite reduction.\\
    I'm not aware of good general-purpose solutions.\\[2em]
    Also: test case reduction; \\
    we'll talk about that in the fuzzing module.
  \end{changemargin}
\end{frame}

\usebackgroundtemplate{}
\part{Implicit Oracles}
\begin{frame}
  \partpage
  
\end{frame}

\usebackgroundtemplate{\tikz\node[opacity=0.1]{\includegraphics[width=\paperwidth, trim=0 0 0 -10em]{L01/00856_destroyed_bridge_ribbon_falls.JPG}};}
\begin{frame}
  \frametitle{Segfaults: always bad}
  \Large
  \begin{changemargin}{2em}
    \includegraphics[width=.8\paperwidth]{L05/segfault.png} \\[.3em]
    Can always label as bad: Buffer overflows, segfaults, etc. \\[1em]
    Might need a tool (e.g. Valgrind, AddressSanitizer) to identify some undefined behaviour.\\[1em]
    Don't need any domain knowledge here.
  \end{changemargin}
\end{frame}

\begin{frame}
  \frametitle{Also bad (what is ``etc'')}
  \Large
  \begin{changemargin}{2em}
    \begin{itemize}
    \item other crashes \\
      \hspace*{2em}(but: uncaught exception vs \\
      \hspace*{3em} quiet quitting?)
    \item race conditions, livelock, deadlock
    \item memory leaks, performance degradations
    \end{itemize}
  \end{changemargin}
\end{frame}

\usebackgroundtemplate{\tikz\node[opacity=0.3]{\includegraphics[width=\paperwidth]{L03/09038_lots_of_moss_v1.JPG}};}
\begin{frame}
  \frametitle{Fuzzing \& Implicit Oracles}
  \Large
  \begin{changemargin}{2em}
    Preview of fuzzing lectures: \\[1em]
    because we autogenerate heaps of inputs, \\
    we have no way of checking their outputs.\\[2em]

    Can only check implicit oracles: no broken assertions, no crashes, use other sanitizers.\\[1em]

    Even less evidence for correctness than artisanal tests.
  \end{changemargin}
\end{frame}

\usebackgroundtemplate{}
\part{Specification-based Oracles}
\begin{frame}
  \partpage
\end{frame}

\begin{frame}
  \frametitle{Enabling Verification}
  \Large
  \begin{changemargin}{2em}
    What should the implementation do?\\[1em]
    One answer: what the specification says.\\[2em]
    Specification: a description of [a part of] a system.
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Model-based specification}
  \Large
  \begin{changemargin}{2em}
    Use modelling languages to describe system behaviour.\\[1em]
    e.g. an Alloy action predicate:
\begin{lstlisting}[basicstyle=\small]
pred upload [f : File] {
  f not in uploaded         // guard
  uploaded' = uploaded + f  // effect on uploaded
  trashed' = trashed        // no effect on trashed
  shared' = shared          // no effect on shared
}
\end{lstlisting}
says what changes in the model when a file is uploaded---acts as an oracle.\\
System state is modelled by sets or relations.
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Using the Model}
  \Large
  \begin{changemargin}{2em}
    Can write test cases verifying the specified behaviour:
    \begin{itemize}
      \item what happens if we upload an already-uploaded file?
      \item when we upload a file, does the file appear in the uploaded set?
    \end{itemize}
    Need to translate between the model's sets and the implementation's data structures.
    
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Modelling in the Implementation Language}
  \Large
  \begin{changemargin}{2em}
    Instead of a dedicated modelling language, use
    the program's data structures.\\[1em]
    This is back to writing assertions.\\[1em]
    Also: preconditions, postconditions, invariants
    (possibly with specialized syntax e.g. @ensures).
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Modelling example}
  \Large
  \begin{changemargin}{2em}
\begin{lstlisting}[language=Python]
  # partially self-verifying
  # appendToList implementation
def appendToList(l,elem):
  l.append(elem)
  assert elem in l
\end{lstlisting}
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Implementation Language Modelling Challenges}
  \Large
  \begin{changemargin}{2em}
    e.g. for a disk-based filesystem, can't verify using in-memory info.\\[1em]

    some conditions are expensive to verify, e.g. is a linked list acyclic?
  \end{changemargin}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Assertions as Explicit Oracles}
  \Large
  \begin{changemargin}{2em}
    The conditions embedded in the assertions are explicit oracles (not implicit).\\[1em]
    Your test case arranges and acts, and then uses the embedded explicit oracles.\\[1em]
    Embedded assertion failure = test case failure (like implicit oracles): a bit more assurance.\\[1em]
    Model-based specifications still better.
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{State Transition Systems}
  \Large
  \begin{changemargin}{2em}
Kind of similar to model-based specification; turnstile example from Wikipedia:
\begin{center}
  \includegraphics[width=.5\textwidth]{L05/Turnstile_state_machine_colored.png}
\end{center}
Use the FSM as a test oracle---e.g. inserting a coin in a locked turnstile should result in an unlocked turnstile.
\\[1em]

You can write a test to check this.

  \end{changemargin}
\end{frame}

\usebackgroundtemplate{}
\part{Derived Test Oracles}
\begin{frame}
  \partpage
\end{frame}

\begin{frame}
  \frametitle{Not Enough Specs}
  \Large
  \begin{changemargin}{2em}
    Often, there are no specifications, or the specifications are insufficient or unhelpful.\\[1em]
    Derived test oracles of various sorts:
    \begin{itemize}
    \item pseudo-oracles;
    \item regression testing;
    \item textual documentation;
    \item specification mining;
    \item metamorphic testing.
    \end{itemize}
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Pseudo-Oracles}
  \Large
  \begin{changemargin}{2em}
    You have to test this imperative implementation:
\begin{lstlisting}[language=Python,basicstyle=\small]
def fib_imperative(n):
    a = 1
    b = 1
    next = b  
    count = 1
    seq = [1, 1]

    while count <= n:
        count += 1
        a, b = b, next
        next = a + b
        seq.append(next)
    return seq
\end{lstlisting}
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Recursive fib}
  \Large
  \begin{changemargin}{2em}
The recursive implementation matches the definition of fib closely:
\begin{lstlisting}[language=Python,basicstyle=\small]
def fib_recursive(n):
    if n == 0:
        return 0
    elif n == 1 or n == 2:
        return 1
    return fib(n-1) + fib(n-2)
\end{lstlisting}
Create tests (perhaps automatically) that compare outputs of the two versions.\\[0.5em]

Generalization: $N$-version programming, vote on the most popular answer.\\[0.5em]
Sort of an oracle, though if all versions implement the wrong spec, you still lose.

  \end{changemargin}
\end{frame}

\begin{frame}
  \frametitle{Regression Testing as Pseudo-Oracles}
  \Large
  \begin{changemargin}{2em}
    One can consider the earlier version to be a sort of pseudo-oracle.\\[1em]
    But a perfective change in the software means that the earlier version was actually wrong,\\
    or maybe the specifications have changed.
    
  \end{changemargin}
\end{frame}

\begin{frame}
  \frametitle{Textual documentation}
  \Large
  \begin{changemargin}{2em}
    Words also serve as a source of truth.\\[1em]
    Historically: then deciphered by humans, \\
    and converted into specifications.
  \end{changemargin}
\end{frame}

\begin{frame}
  \frametitle{Specification mining}
  \Large
  \begin{changemargin}{2em}
    Lots of work on observing program executions \\
    and deriving specifications (invariants and more generally).\\[1em]
    Won't talk about that in this course,\\
    but Daikon is one research tool that does this.
  \end{changemargin}
\end{frame}

\usebackgroundtemplate{\tikz\node[opacity=0.1]{\includegraphics[width=\paperwidth]{L06/06919_chalk_v1.jpg}};}
\part{Metamorphic Testing}
\begin{frame}
  \partpage
  
  {\scriptsize\vspace*{10em}
    Background: schist---metamorphic rock.
  }
\end{frame}
\usebackgroundtemplate{}

\usebackgroundtemplate{\tikz\node[opacity=0.1]{\includegraphics[width=\paperwidth]{L05/960px-Delphi_Temple_of_Apollo.jpeg}};}
\begin{frame}
  \frametitle{No Oracle? Now what?}
  \Large
  \begin{changemargin}{2em}
    Want to run zillions of tests. \\
    What's the expected output?\\[1em]

    We had implicit oracles, e.g. ``doesn't crash''.\\[1em]

    Can we do better?
  \end{changemargin}
\end{frame}
\usebackgroundtemplate{}

\begin{frame}[fragile]
  \frametitle{Consider min}
  \Large
  \begin{changemargin}{2em}
    Suspend disbelief \& pretend we have no oracle:
\begin{python}
def min(a,b):
    if a < b:
        return a
    else:
        return b
\end{python}
    How can we generate heaps of tests?
  \end{changemargin}
\end{frame}

\begin{frame}[fragile]
  \frametitle{``New tests from old''}
  \begin{center}
    \includegraphics[width=.4\textwidth]{L06/20220802_042715719_lamp.jpg}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{``New tests from old'' II}

  \Huge
  \begin{changemargin}{2em}
    Say \texttt{min(3, 5) = X}.\\[2em]
    Can we construct another test case with known output?
  \end{changemargin}
\end{frame}

\begin{frame}
  \frametitle{``New tests from old'' III}

\Large
  \begin{changemargin}{2em}
    \texttt{min(5, 3) = X} also.\\[2em]
    A simple example of metamorphic testing:\\
    even if you don't know X, it's the same X:\\[1em]
    \texttt{min(5, 3) = min(3, 5)}.\\[1em]
    Always domain-specific.
  \end{changemargin}
\end{frame}


\begin{frame}
  \frametitle{Observations on metamorphic testing}
  \Large
  \begin{changemargin}{1em}
    You are testing $f$ and you have input $x_0$.
    \begin{enumerate}
    \item given one input $x_0$, generate another input $x_1$;
    \item you know some property of $f(x_1)$ in relation to $f(x_0)$;
    \item you don't necessarily know $f(x_1)$;
      \item in fact, you don't need to know $f(x_0)$ in advance!
    \end{enumerate}
  \end{changemargin}
\end{frame}

\begin{frame}
  \frametitle{min and metamorphic testing: no outputs}
  \Large
  \begin{changemargin}{2em}
    You can randomly generate 1 zillion test inputs for \texttt{min}.\\[1em]
    By our assumption, we don't have the corresponding outputs, \\ just that \texttt{min} shouldn't crash.
  \end{changemargin}
\end{frame}

\begin{frame}
  \frametitle{min and metamorphic testing: what we have}
  \Large
  \begin{changemargin}{2em}
    \begin{itemize}
    \item can generate another 1 zillion test cases, by inverting parameter order.
    \item also don't have outputs for these cases, but
    \item we know that it should be the same as the uninverted input!
    \end{itemize}
    That's something, which is better than nothing.
  \end{changemargin}
\end{frame}

\begin{frame}
  \frametitle{Another example: search}
  \includegraphics[width=\textwidth]{L06/duckduckgo.png}
\end{frame}

\begin{frame}
  \frametitle{Exclusion}
  \Large
  \begin{changemargin}{2em}
    \begin{enumerate}
    \item Search for ``metamorphic''.
    \item Get, say, 3300 results.
    \item Search for ``metamorphic -testing \\ \qquad (i.e. exclude tesing).
    \item Now get 4200 results.
    \item ???
    \end{enumerate}
    ~\\
    How do we use this insight to get new tests from old?
  \end{changemargin}
\end{frame}
  
\begin{frame}
  \frametitle{Another example: speech-to-text}
  \begin{center}
    \includegraphics[width=.6\textwidth]{L06/20260119_022953163_microphone.jpg}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Speech-to-text scenario}
  \Large
  \begin{changemargin}{2em}
    You are writing a speech-to-text processor.\\[1em]
  \begin{center}
    \includegraphics[width=.2\textwidth]{L06/20260119_022953163_microphone.jpg}
  \end{center}
    Input: audio file.\\
    Output: text.
  \end{changemargin}
\end{frame}

\begin{frame}
  \frametitle{Testing speech-to-text}
  \Large
  \begin{changemargin}{2em}
    \begin{enumerate}
    \item manual test generation: you record a text and compare to known good output (oracle).
    \item you (or I) get 130 students to do that.
    \item you generate audio using text-to-speech.
    \item you use Mechanical Turk to get audio.
    \end{enumerate}
    ~\\
    Still not even close to covering the space of valid inputs, e.g. accents.
  \end{changemargin}
\end{frame}

\begin{frame}
  \frametitle{Getting lots of inputs\ldots}
  \Large
  \begin{changemargin}{2em}
    Well, there are a lot of audio files on the Internet\ldots \\[2em]
    \ldots but there is no ground truth, and human oracles are expensive.
  \end{changemargin}
\end{frame}

\begin{frame}
  \frametitle{What about property testing?}
  \Large
  \begin{changemargin}{2em}
    ``It doesn't crash on any input.'' OK\ldots\\
    ``It doesn't transcribe acoustic music into words.'' I guess?\\[2em]
    These properties don't really validate the system.
  \end{changemargin}
\end{frame}

\begin{frame}
  \frametitle{Transforming inputs}
  \Large
  \begin{changemargin}{2em}
    Let's say you have one input, which transcribes to \texttt{out}. You can:
    \begin{itemize}
    \item double the volume; or, 
    \item raise the pitch; or,
    \item increase the tempo; or,
    \item add background static; or,
    \item add traffic noises; or,
    \item combine any of these.
    \end{itemize}
  \end{changemargin}
\end{frame}

\begin{frame}
  \frametitle{Implications of transforming inputs}
  \Large
  \begin{changemargin}{2em}
    ``add traffic noises'' has a lot of freedom; \\
    you can add 10 different traffic noises.\\[1em]
    Then, double the volume on each of them;\\
    now have 22 test cases.\\[1em]
    etc.\\[1em]
  \end{changemargin}
\end{frame}

\begin{frame}
  \frametitle{Further implications}
  \Large
  \begin{changemargin}{2em}
    What's more, you know the output for all these cases.\\
    
    Your tests cover much more of the input space.\\
    Still no accents, though.\\[1em]
    What if you didn't have the known output?\\
    Can download any audio from the Internet.\\
    Still have the equality relation with the transformed inputs.
  \end{changemargin}
\end{frame}

\begin{frame}
  \frametitle{Example: YouTube search}
  \includegraphics[width=\textwidth]{L06/metamorphic-youtube.png}
\end{frame}

\begin{frame}
  \frametitle{Example: tagged image search}
  \includegraphics[width=\textwidth]{L06/fauna.png}
\end{frame}

\begin{frame}
  \frametitle{Example: tagged image search}
  \Large
  \begin{changemargin}{2em}
    For our example: tags ``red'' and ``blue''.\\
    An image may be tagged both ``red'' and ``blue''.\\[1em]

    Say there are 4 images. \\
    \{1, 2, 3\} are tagged ``red''.\\
    \{1, 2, 4\} are tagged ``blue''.
  \end{changemargin}
\end{frame}

\begin{frame}
  \frametitle{Some tagged image search queries}
  \Large
  \begin{changemargin}{2em}
    Query: ``has any tag'': \{ 1, 2, 3, 4\} (n=4).\\
    Query: ``red'': \{1, 2, 3\} (n=3).\\
    Query: ``blue'': \{1, 2, 4\} (n=3).\\[1em]
    It must be that
    \[ 3 + 3~ (red + blue) \ge 4 ~(any). \]
  \end{changemargin}
\end{frame}

\begin{frame}
  \frametitle{Metamorphic relation output patterns}
  \Large
  \begin{changemargin}{2em}
    A list of patterns from the paper:
    \begin{itemize}
    \item equivalence: same output items, perhaps in different order;
    \item equality: same output items, same order;
    \item subset: follow-up output has a subset of original output;
    \item disjoint: source and follow-up outputs have no items in common;
    \item complete: union of follow-up outputs completely make up source output;
    \item difference: source and follow-up outputs differ by a specific set $D$.
    \end{itemize}
  \end{changemargin}
\end{frame}

\begin{frame}
  \frametitle{Metamorphic relation output pattern: equivalence}
  \Large
  \begin{changemargin}{2em}
    Source input is a query.\\
    Follow-up input is the same query but with some different ordering requested, like ``sort by date''.\\[1em]
    Expect: same items in outputs, but different order.
  \end{changemargin}
\end{frame}

\begin{frame}
  \frametitle{Metamorphic relation output pattern: equality}
  \Large
  \begin{changemargin}{2em}
    Had this in the \texttt{min} example at start; also speech-to-text.\\[1em]

    Another example: \\
    \begin{changemargin}{1em}
    Source input is a query.\\
    Follow-up input is the same query but explicitly requesting the default ordering (e.g. sort by relevance).\\[1em]
    Expect: same items in outputs, with same order.
    \end{changemargin}
  \end{changemargin}
\end{frame}

\begin{frame}
  \frametitle{Metamorphic relation output pattern: subset}
  \Large
  \begin{changemargin}{2em}
    Search engine example with exclusions was like this.\\[1em]
    Another example: \\
    \begin{changemargin}{1em}
    Source input is a geolocation query with radius of 50km.\\
    Follow-up input is the same query but a smaller radius.\\[1em]
    Expect: follow-up output is subset of source output.
    \end{changemargin}
  \end{changemargin}
\end{frame}

\begin{frame}
  \frametitle{Metamorphic relation output pattern: disjoint}
  \Large
  \begin{changemargin}{2em}
    Example: \\
    \begin{changemargin}{1em}
    source input = Spotify albums of ``michael buble'' from 2012,\\
 follow-up input = Spotify albums of ``michael buble'' from 2014. \\[1em]
Expect: there should be no items in both the source and the follow-up output sets.
    \end{changemargin}
  \end{changemargin}
\end{frame}

\begin{frame}
  \frametitle{Metamorphic relation output pattern: complete}
  \Large
  \begin{changemargin}{2em}
    This is a relation between the source output and the set of follow-up outputs.\\[1em]

    Example context: There are short, medium, and long YouTube
    videos. \\[1em]

    If the source input is for keyword ``testing'', then one can make three follow-up inputs: short ``testing'', medium ``testing'', and long ``testing''.\\[1em]
    
    Expect: combined, the results for short, medium, and long ``testing'' videos should be the same as the results for just ``testing''.
  \end{changemargin}
\end{frame}

\begin{frame}
  \frametitle{Metamorphic relation output pattern: difference}
  \Large
  \begin{changemargin}{2em}
    Example:
    \begin{changemargin}{1em}
    I upload two videos which I know to be similar except for the length and title. \\
    The create operation returns properties of the uploaded video.\\[1em]
    Expect: the source and follow-up metadata only differ on length and title,\\
    $\qquad$ other properties may be the same.
    \end{changemargin}
  \end{changemargin}
\end{frame}

\end{document}
